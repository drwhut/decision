

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Syntax Analysis &mdash; Decision 0.1.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Semantic Analysis" href="semantic_analysis.html" />
    <link rel="prev" title="Lexical Analysis" href="lexical_analysis.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Decision
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../the_language/index.html">The Language</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Stages of Compilation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lexical_analysis.html">Lexical Analysis</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Syntax Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#structures">Structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#meta-variables">Meta-variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#syntax-functions">Syntax functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="semantic_analysis.html">Semantic Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="error_reporting.html">Error Reporting</a></li>
<li class="toctree-l2"><a class="reference internal" href="code_generation.html">Code Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimisation.html">Optimisation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../linking/index.html">Linking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../the_virtual_machine/index.html">The Virtual Machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Decision</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Stages of Compilation</a> &raquo;</li>
        
      <li>Syntax Analysis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/the_stages_of_compilation/syntax_analysis.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="syntax-analysis">
<span id="id1"></span><h1>Syntax Analysis<a class="headerlink" href="#syntax-analysis" title="Permalink to this headline">¶</a></h1>
<p>Syntax Analysis is performed in <code class="docutils literal notranslate"><span class="pre">dsyntax.c</span></code> and <code class="docutils literal notranslate"><span class="pre">dsyntax.h</span></code>.</p>
<p>The aim of Syntax Analysis is to determine whether the user wrote the source
code <em>correctly</em> in terms of the structure of the program. This is done by
generating a <strong>syntax tree</strong>, which not only helps us later with analysing
the code but also helps us find any syntax errors in the code.</p>
<p>The syntax tree has a root node, which represents the entire program.
The children of the root node would then be the statements in the program,
then those statements would have the name, the arguments, and the outputs
as their children, etc.</p>
<p>Since the syntax of the language doesn’t allow for nested statements like in
other languages, we use a <em>top-down</em> method of creating the syntax tree
rather than using grammars and <em>bottom-up</em> methods which can handle nested
statements. Therefore in the compiler, we use the
<a class="reference external" href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive-descent</a>
method to convert the lexical stream from <a class="reference internal" href="lexical_analysis.html#lexical-analysis"><span class="std std-ref">Lexical Analysis</span></a> to a
syntax tree.</p>
<div class="section" id="structures">
<h2>Structures<a class="headerlink" href="#structures" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SyntaxDefinition</span></code></dt><dd><p>An enumerator representing the definitions of syntax statements, for
example, there will be one for line identifiers, another for arguments,
another for statements as a whole, etc.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is one special value in <code class="docutils literal notranslate"><span class="pre">SyntaxDefinition</span></code> which is
<code class="docutils literal notranslate"><span class="pre">STX_TOKEN</span> <span class="pre">=</span> <span class="pre">0</span></code>, which represents a lexical token.</p>
</div>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">SyntaxContext</span></code></dt><dd><p>A structure that, during Syntax Analysis, keeps track of data like where
we are in the lexical stream, what the current <code class="docutils literal notranslate"><span class="pre">LexToken</span></code> is, etc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SytaxNode</span></code></dt><dd><p>A node in the syntax tree. It contains a <code class="docutils literal notranslate"><span class="pre">SyntaxDefinition</span></code>, and a
reference to a lexical token (<code class="docutils literal notranslate"><span class="pre">LexToken*</span></code>) to preserve the info gathered
by <a class="reference internal" href="lexical_analysis.html#lexical-analysis"><span class="std std-ref">Lexical Analysis</span></a> - however, it only stores the said reference is
the <code class="docutils literal notranslate"><span class="pre">SyntaxDefinition</span></code> is <code class="docutils literal notranslate"><span class="pre">STX_TOKEN</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
<p>Each node also stores 2 pointers to other syntax nodes (<code class="docutils literal notranslate"><span class="pre">SyntaxNode*</span></code>),
which make up the structure of the tree. One is the <em>direct child</em> of the
node, and the other is the <em>next sibling</em> of the node. The reason for
this structure is so that we don’t have to store a dynamic list of
children, which in C is a pain.</p>
<p>Therefore, the syntax tree as a whole is represented as a pointer
(<code class="docutils literal notranslate"><span class="pre">SyntaxNode*</span></code>) to the root node.</p>
</dd>
</dl>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="meta-variables">
<h3>Meta-variables<a class="headerlink" href="#meta-variables" title="Permalink to this headline">¶</a></h3>
<p>Each <code class="docutils literal notranslate"><span class="pre">SyntaxDefinition</span></code> has an associated function called a
<strong>meta-variable</strong> in <code class="docutils literal notranslate"><span class="pre">dsyntax.c</span></code>, which returns if the section of lexical
tokens we’re looking at fits the syntax rule of the meta-variable, and may
potentially throw an error if it specifically breaks the rules (but not if
none of the lexical tokens are valid, as they may be valid in another
definition)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These functions have a <em>lot</em> of preprocessor macros that hide a lot of
what is going on under the hood - this is because all of these functions
do a lot of similar things, and it makes it easier in the long run to
create new rules, as the macros represent concepts similar to something
you would see in, say, Backus-Naur form.</p>
</div>
<p>Here is an example of a meta-variable for a <em>call</em>, which is a list of
arguments (that could be empty), surrounded by brackets:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* &lt;call&gt; ::= &lt;Lbracket&gt;&lt;listOfArguments&gt;&lt;Rbracket&gt; */</span>
<span class="n">META</span><span class="p">(</span><span class="n">call</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">acceptToken</span><span class="p">(</span><span class="n">TK_LBRACKET</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">START_ADD</span>
        <span class="n">acceptDefinition</span><span class="p">(</span><span class="n">listOfArguments</span><span class="p">);</span> <span class="c1">// There dosen&#39;t nessesarily have to</span>
        <span class="n">END_ADD</span>                            <span class="c1">// be anything in the backets.</span>

        <span class="n">expectToken</span><span class="p">(</span><span class="n">TK_RBRACKET</span><span class="p">,</span> <span class="s">&quot;Expected ) symbol at end of call&quot;</span><span class="p">);</span>
        <span class="n">ACCEPT</span><span class="p">(</span><span class="n">call</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">DECLINE</span><span class="p">(</span><span class="n">call</span><span class="p">)</span>
    <span class="p">}</span>

<span class="n">END_META</span>
</pre></div>
</div>
<p>Here it will accept a list of arguments if it finds one, but if it doesn’t
then it will not error - but it will error if after there isn’t a right
bracket. Also notice that if there is no left bracket it doesn’t error, but
simply says “this cannot be a call, try something else”.</p>
</div>
<div class="section" id="syntax-functions">
<h3>Syntax functions<a class="headerlink" href="#syntax-functions" title="Permalink to this headline">¶</a></h3>
<p>In <code class="docutils literal notranslate"><span class="pre">dsyntax.h</span></code>, there are a few functions to help you traverse and
manipulate a syntax tree, for instance:</p>
<dl class="function">
<dt>
void <code class="sig-name descname">d_syntax_add_child</code><span class="sig-paren">(</span><a class="reference internal" href="../reference/index.html#_CPPv410SyntaxNode" title="SyntaxNode">SyntaxNode</a> *<em>parent</em>, <a class="reference internal" href="../reference/index.html#_CPPv410SyntaxNode" title="SyntaxNode">SyntaxNode</a> *<em>child</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Add a child node to a parent node. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">parent</span></code>: The parent node to attach the child onto. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">child</span></code>: The child node to add onto the parent. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>The <code class="docutils literal notranslate"><span class="pre">child</span></code> node is added as the next child of the <code class="docutils literal notranslate"><span class="pre">parent</span></code> node.</p>
<dl class="function">
<dt>
size_t <code class="sig-name descname">d_syntax_get_num_children</code><span class="sig-paren">(</span><a class="reference internal" href="../reference/index.html#_CPPv410SyntaxNode" title="SyntaxNode">SyntaxNode</a> *<em>parent</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get how many children a node has. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The number of children <code class="docutils literal notranslate"><span class="pre">parent</span></code> has.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">parent</span></code>: The node to query. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>Returns the number of children that <code class="docutils literal notranslate"><span class="pre">parent</span></code> has.</p>
<p>There is also a mechanism to help you find all of the syntax nodes with a
given <code class="docutils literal notranslate"><span class="pre">SyntaxDefinition</span></code>:</p>
<dl class="function">
<dt>
<a class="reference internal" href="../reference/index.html#_CPPv418SyntaxSearchResult" title="SyntaxSearchResult">SyntaxSearchResult</a> <code class="sig-name descname">d_syntax_get_all_nodes_with</code><span class="sig-paren">(</span><a class="reference internal" href="../reference/index.html#_CPPv410SyntaxNode" title="SyntaxNode">SyntaxNode</a> *<em>root</em>, <a class="reference internal" href="../reference/index.html#_CPPv416SyntaxDefinition" title="SyntaxDefinition">SyntaxDefinition</a> <em>definition</em>, bool <em>traverseChildrenOfFound</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Return all occurances of a tree with a given definition as a malloc’d SyntaxSearchResult. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A malloc’d SyntaxSearchResult.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">root</span></code>: The root node to search from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">definition</span></code>: The definition we want our found nodes to have. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">traverseChildrenOfFound</span></code>: If we find a node that we want, should w also traverse the children of that found node? </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>Returns a list of <code class="docutils literal notranslate"><span class="pre">SyntaxNode*</span></code> which have the same <code class="docutils literal notranslate"><span class="pre">SyntaxDefinition</span></code> as
<code class="docutils literal notranslate"><span class="pre">definition</span></code>. It also gives you the choice of whether you want to continue
traversing the children of a satisfactory node to try and find more, although
this will mostly be false as certain syntax definitions will only appear in
certain layers of the tree.</p>
<p>Because C is our bestest friend in the world, we need to free the results once
we’re done with them:</p>
<dl class="function">
<dt>
void <code class="sig-name descname">d_syntax_free_results</code><span class="sig-paren">(</span><a class="reference internal" href="../reference/index.html#_CPPv418SyntaxSearchResult" title="SyntaxSearchResult">SyntaxSearchResult</a> <em>results</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Free search results from memory. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">results</span></code>: The results to free. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>However, the <em>most important function</em> is:</p>
<dl class="function">
<dt>
<a class="reference internal" href="../reference/index.html#_CPPv412SyntaxResult" title="SyntaxResult">SyntaxResult</a> <code class="sig-name descname">d_syntax_parse</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../reference/index.html#_CPPv410_lexStream" title="_lexStream">_lexStream</a> <em>stream</em>, <em class="property">const</em> char *<em>filePath</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Parse a lexical stream, and generate a syntax tree. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The malloc’d root node of the syntax tree, and whether the parsing was successful or not.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">stream</span></code>: The stream to parse from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">filePath</span></code>: In case we error, say what the file path was. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>Returns the root node of a syntax tree, given the <code class="docutils literal notranslate"><span class="pre">stream</span></code> from
<a class="reference internal" href="lexical_analysis.html#lexical-analysis"><span class="std std-ref">Lexical Analysis</span></a>. In the event there is an error, it blames
<code class="docutils literal notranslate"><span class="pre">filePath</span></code>.</p>
<dl class="function">
<dt>
void <code class="sig-name descname">d_syntax_free_tree</code><span class="sig-paren">(</span><a class="reference internal" href="../reference/index.html#_CPPv410SyntaxNode" title="SyntaxNode">SyntaxNode</a> *<em>root</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Free all the nodes from a syntax tree. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">root</span></code>: The root node of the tree. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>Frees the syntax tree after we are done with it.</p>
<p>Like in <a class="reference internal" href="lexical_analysis.html#lexical-analysis"><span class="std std-ref">Lexical Analysis</span></a>, there is a debugging method:</p>
<dl class="function">
<dt>
void <code class="sig-name descname">d_syntax_dump_tree</code><span class="sig-paren">(</span><a class="reference internal" href="../reference/index.html#_CPPv410SyntaxNode" title="SyntaxNode">SyntaxNode</a> *<em>root</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Dump the contents of a tree recursively. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">root</span></code>: The root node to start from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>Dumps the syntax tree with indentation depending on the depth of the node.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The syntax gets dumped automatically whenever you compile source code with
a <code class="docutils literal notranslate"><span class="pre">VERBOSE_LEVEL</span></code> of 4 or higher.</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="semantic_analysis.html" class="btn btn-neutral float-right" title="Semantic Analysis" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lexical_analysis.html" class="btn btn-neutral float-left" title="Lexical Analysis" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Benjamin Beddows

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>