

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Syntax Analysis &mdash; Decision 0.3.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Semantic Analysis" href="semantic_analysis.html" />
    <link rel="prev" title="Lexical Analysis" href="lexical_analysis.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Decision
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../the_language/index.html">The Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../common_data_structures/index.html">Common Data Structures</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Stages of Compilation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lexical_analysis.html">Lexical Analysis</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Syntax Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#structures">Structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#meta-variables">Meta-variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#syntax-functions">Syntax functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="semantic_analysis.html">Semantic Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="error_reporting.html">Error Reporting</a></li>
<li class="toctree-l2"><a class="reference internal" href="code_generation.html">Code Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimisation.html">Optimisation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../linking/index.html">Linking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../the_virtual_machine/index.html">The Virtual Machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../the_c_api/index.html">The C API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Decision</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Stages of Compilation</a> &raquo;</li>
        
      <li>Syntax Analysis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/the_stages_of_compilation/syntax_analysis.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="syntax-analysis">
<span id="id1"></span><h1>Syntax Analysis<a class="headerlink" href="#syntax-analysis" title="Permalink to this headline">¶</a></h1>
<p>Syntax Analysis is performed in <code class="docutils literal notranslate"><span class="pre">dsyntax.c</span></code> and <code class="docutils literal notranslate"><span class="pre">dsyntax.h</span></code>.</p>
<p>The aim of Syntax Analysis is to determine whether the user wrote the source
code <em>correctly</em> in terms of the structure of the program. This is done by
generating a <strong>syntax tree</strong>, which not only helps us later with analysing
the code but also helps us find any syntax errors in the code.</p>
<p>The syntax tree has a root node, which represents the entire program.
The children of the root node would then be the statements in the program,
then those statements would have the name, the arguments, and the outputs
as their children, etc.</p>
<p>Since the syntax of the language doesn’t allow for nested statements like in
other languages, we use a <em>top-down</em> method of creating the syntax tree
rather than using grammars and <em>bottom-up</em> methods which can handle nested
statements. Therefore in the compiler, we use the
<a class="reference external" href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive-descent</a>
method to convert the lexical stream from <a class="reference internal" href="lexical_analysis.html#lexical-analysis"><span class="std std-ref">Lexical Analysis</span></a> to a
syntax tree.</p>
<div class="section" id="structures">
<h2>Structures<a class="headerlink" href="#structures" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SyntaxDefinition</span></code></dt><dd><p>An enumerator representing the definitions of syntax statements, for
example, there will be one for line identifiers, another for arguments,
another for statements as a whole, etc.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is one special value in <code class="docutils literal notranslate"><span class="pre">SyntaxDefinition</span></code> which is
<code class="docutils literal notranslate"><span class="pre">STX_TOKEN</span> <span class="pre">=</span> <span class="pre">0</span></code>, which represents a lexical token.</p>
</div>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">SyntaxContext</span></code></dt><dd><p>A structure that, during Syntax Analysis, keeps track of data like where
we are in the lexical stream, what the current <code class="docutils literal notranslate"><span class="pre">LexToken</span></code> is, etc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SytaxNode</span></code></dt><dd><p>A node in the syntax tree. It contains a <code class="docutils literal notranslate"><span class="pre">SyntaxDefinition</span></code>, and a
reference to a lexical token (<code class="docutils literal notranslate"><span class="pre">LexToken*</span></code>) to preserve the info gathered
by <a class="reference internal" href="lexical_analysis.html#lexical-analysis"><span class="std std-ref">Lexical Analysis</span></a> - however, it only stores the said reference is
the <code class="docutils literal notranslate"><span class="pre">SyntaxDefinition</span></code> is <code class="docutils literal notranslate"><span class="pre">STX_TOKEN</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
<p>Each node also stores 2 pointers to other syntax nodes (<code class="docutils literal notranslate"><span class="pre">SyntaxNode*</span></code>),
which make up the structure of the tree. One is the <em>direct child</em> of the
node, and the other is the <em>next sibling</em> of the node. The reason for
this structure is so that we don’t have to store a dynamic list of
children, which in C is a pain.</p>
<p>Therefore, the syntax tree as a whole is represented as a pointer
(<code class="docutils literal notranslate"><span class="pre">SyntaxNode*</span></code>) to the root node.</p>
</dd>
</dl>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="meta-variables">
<h3>Meta-variables<a class="headerlink" href="#meta-variables" title="Permalink to this headline">¶</a></h3>
<p>Each <code class="docutils literal notranslate"><span class="pre">SyntaxDefinition</span></code> has an associated function called a
<strong>meta-variable</strong> in <code class="docutils literal notranslate"><span class="pre">dsyntax.c</span></code>, which returns if the section of lexical
tokens we’re looking at fits the syntax rule of the meta-variable, and may
potentially throw an error if it specifically breaks the rules of that
meta-variable.</p>
<p>Here is an example of a meta-variable for a <em>line identifier</em>, which is a line
symbol (<code class="docutils literal notranslate"><span class="pre">#</span></code>), followed by an integer literal:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* &lt;lineIdentifier&gt; ::= &lt;Line&gt;&lt;IntegerLiteral&gt; */</span>
<span class="k">static</span> <span class="n">SyntaxResult</span> <span class="nf">lineIdentifier</span><span class="p">(</span><span class="n">SyntaxContext</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SyntaxResult</span> <span class="n">out</span><span class="p">;</span>
    <span class="n">out</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">d_syntax_create_node</span><span class="p">(</span><span class="n">STX_lineIdentifier</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">lineNum</span><span class="p">);</span>
    <span class="n">out</span><span class="p">.</span><span class="n">success</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="n">VERBOSE</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;ENTER</span><span class="se">\t</span><span class="s">lineIdentifier</span><span class="se">\t</span><span class="s">WITH</span><span class="se">\t</span><span class="s">%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
            <span class="n">context</span><span class="o">-&gt;</span><span class="n">currentToken</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">currentToken</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TK_LINE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nextToken</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">currentToken</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TK_INTEGERLITERAL</span><span class="p">)</span> <span class="p">{</span>

            <span class="n">SyntaxNode</span> <span class="o">*</span><span class="n">literal</span> <span class="o">=</span> <span class="n">d_syntax_create_node</span><span class="p">(</span>
                <span class="n">STX_TOKEN</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">currentToken</span><span class="p">,</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">lineNum</span><span class="p">);</span>
            <span class="n">d_syntax_add_child</span><span class="p">(</span><span class="n">out</span><span class="p">.</span><span class="n">node</span><span class="p">,</span> <span class="n">literal</span><span class="p">);</span>

            <span class="n">nextToken</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>

        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">syntax_error</span><span class="p">(</span>
                <span class="s">&quot;Expected integer literal to follow the line symbol (#)&quot;</span><span class="p">,</span>
                <span class="n">context</span><span class="p">);</span>
            <span class="n">fail_definition</span><span class="p">(</span><span class="o">&amp;</span><span class="n">out</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">syntax_error</span><span class="p">(</span>
            <span class="s">&quot;Expected line identifier to start with the line symbol (#)&quot;</span><span class="p">,</span>
            <span class="n">context</span><span class="p">);</span>
        <span class="n">fail_definition</span><span class="p">(</span><span class="o">&amp;</span><span class="n">out</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="syntax-functions">
<h3>Syntax functions<a class="headerlink" href="#syntax-functions" title="Permalink to this headline">¶</a></h3>
<p>In <code class="docutils literal notranslate"><span class="pre">dsyntax.h</span></code>, there are a few functions to help you traverse and
manipulate a syntax tree, for instance:</p>
<dl class="function">
<dt>
void <code class="sig-name descname">d_syntax_add_child</code><span class="sig-paren">(</span><a class="reference internal" href="../reference/index.html#_CPPv410SyntaxNode" title="SyntaxNode">SyntaxNode</a> *<em>parent</em>, <a class="reference internal" href="../reference/index.html#_CPPv410SyntaxNode" title="SyntaxNode">SyntaxNode</a> *<em>child</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Add a child node to a parent node. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">parent</span></code>: The parent node to attach the child onto. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">child</span></code>: The child node to add onto the parent. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
size_t <code class="sig-name descname">d_syntax_get_num_children</code><span class="sig-paren">(</span><a class="reference internal" href="../reference/index.html#_CPPv410SyntaxNode" title="SyntaxNode">SyntaxNode</a> *<em>parent</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get how many children a node has. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The number of children <code class="docutils literal notranslate"><span class="pre">parent</span></code> has.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">parent</span></code>: The node to query. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>There is also a mechanism to help you find all of the syntax nodes with a
given <code class="docutils literal notranslate"><span class="pre">SyntaxDefinition</span></code>:</p>
<dl class="function">
<dt>
<a class="reference internal" href="../reference/index.html#_CPPv418SyntaxSearchResult" title="SyntaxSearchResult">SyntaxSearchResult</a> <code class="sig-name descname">d_syntax_get_all_nodes_with</code><span class="sig-paren">(</span><a class="reference internal" href="../reference/index.html#_CPPv410SyntaxNode" title="SyntaxNode">SyntaxNode</a> *<em>root</em>, <a class="reference internal" href="../reference/index.html#_CPPv416SyntaxDefinition" title="SyntaxDefinition">SyntaxDefinition</a> <em>definition</em>, bool <em>traverseChildrenOfFound</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Return all occurances of a tree with a given definition as a malloc’d SyntaxSearchResult. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A malloc’d SyntaxSearchResult.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">root</span></code>: The root node to search from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">definition</span></code>: The definition we want our found nodes to have. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">traverseChildrenOfFound</span></code>: If we find a node that we want, should we also traverse the children of that found node? </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>It returns a list of <code class="docutils literal notranslate"><span class="pre">SyntaxNode*</span></code> which have the same <code class="docutils literal notranslate"><span class="pre">SyntaxDefinition</span></code>
as <code class="docutils literal notranslate"><span class="pre">definition</span></code>. It also gives you the choice of whether you want to continue
traversing the children of a satisfactory node to try and find more, although
this will mostly be false as certain syntax definitions will only appear in
certain layers of the tree.</p>
<p>Because C is our bestest friend in the world, we need to free the results once
we’re done with them:</p>
<dl class="function">
<dt>
void <code class="sig-name descname">d_syntax_free_results</code><span class="sig-paren">(</span><a class="reference internal" href="../reference/index.html#_CPPv418SyntaxSearchResult" title="SyntaxSearchResult">SyntaxSearchResult</a> <em>results</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Free search results from memory. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">results</span></code>: The results to free. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>However, the <em>most important function</em> is:</p>
<dl class="function">
<dt>
<a class="reference internal" href="../reference/index.html#_CPPv412SyntaxResult" title="SyntaxResult">SyntaxResult</a> <code class="sig-name descname">d_syntax_parse</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="../reference/index.html#_CPPv410_lexStream" title="_lexStream">_lexStream</a> <em>stream</em>, <em class="property">const</em> char *<em>filePath</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Parse a lexical stream, and generate a syntax tree. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The malloc’d root node of the syntax tree, and whether the parsing was successful or not.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">stream</span></code>: The stream to parse from. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">filePath</span></code>: In case we error, say what the file path was. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>It returns the root node of a syntax tree, given the <code class="docutils literal notranslate"><span class="pre">stream</span></code> from
<a class="reference internal" href="lexical_analysis.html#lexical-analysis"><span class="std std-ref">Lexical Analysis</span></a>. In the event there is an error, it blames
<code class="docutils literal notranslate"><span class="pre">filePath</span></code>.</p>
<dl class="function">
<dt>
void <code class="sig-name descname">d_syntax_free_tree</code><span class="sig-paren">(</span><a class="reference internal" href="../reference/index.html#_CPPv410SyntaxNode" title="SyntaxNode">SyntaxNode</a> *<em>root</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Free all the nodes from a syntax tree. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">root</span></code>: The root node of the tree. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>This frees the syntax tree after we are done with it.</p>
<p>Like in <a class="reference internal" href="lexical_analysis.html#lexical-analysis"><span class="std std-ref">Lexical Analysis</span></a>, there is a debugging method:</p>
<dl class="function">
<dt>
void <code class="sig-name descname">d_syntax_dump_tree</code><span class="sig-paren">(</span><a class="reference internal" href="../reference/index.html#_CPPv410SyntaxNode" title="SyntaxNode">SyntaxNode</a> *<em>root</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Dump the contents of a tree recursively. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">root</span></code>: The root node to start from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>It dumps the syntax tree with indentation depending on the depth of the node.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The syntax gets dumped automatically whenever you compile source code with
a <code class="docutils literal notranslate"><span class="pre">VERBOSE_LEVEL</span></code> of 4 or higher.</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="semantic_analysis.html" class="btn btn-neutral float-right" title="Semantic Analysis" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lexical_analysis.html" class="btn btn-neutral float-left" title="Lexical Analysis" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019-2020, Benjamin Beddows

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>