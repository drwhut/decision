/*
    Decision
    Copyright (C) 2019  Benjamin Beddows

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * \file dvm.h
 * \brief This header contains functionality for the Decision VM - the object
 * that will run the generated bytecode.
 */

#ifndef DVM_H
#define DVM_H

#include <stdbool.h>
#include "dcfg.h"
#include "derror.h"

#include <stdint.h>

/*
=== HEADER DEFINITIONS ====================================
*/

/**
 * \enum _dIns
 * \brief The Decision VM Instruction Set.
 *
 * \typedef enum _dIns DIns
 */
typedef enum _dIns {
    OP_RET   = 0,  ///< $( pc )  = pop(callStack) ELSE vm.halted = true
    OP_ADD   = 1,  ///< $( r1 )  = $( r1 ) + $( r2 )
    OP_ADDF  = 2,  ///< $( f1 )  = $( f1 ) + $( f2 )
    OP_ADDI  = 3,  ///< $( r )  += W_IMMEDIATE(4/2)
    OP_AND   = 4,  ///< $( r1 )  = $( r1 ) & $( r2 )
    OP_ANDI  = 5,  ///< $( r )  &= IMMEDIATE(4/2)
    OP_CALL  = 6,  ///< push(callStack, $( pc )); $( pc ) = $(r)
    OP_CALLR = 7,  ///< push(callStack, $( pc )); $( pc ) += W_IMMEDIATE(4/2)
    OP_CEQ   = 8,  ///< $( r1 )  = ($( r2 ) == $( r3 )) ? 1 : 0
    OP_CEQF  = 9,  ///< $( r1 )  = ($( f2 ) == $( f3 )) ? 1 : 0
    OP_CEQS  = 10, ///< $( r1 )  = (strcmp($( r2 ), $( r3 )) == 0) ? 1 : 0
    OP_CLEQ  = 11, ///< $( r1 )  = ($( r2 ) <= $( r3 )) ? 1 : 0
    OP_CLEQF = 12, ///< $( r1 )  = ($( f2 ) <= $( f3 )) ? 1 : 0
    OP_CLEQS = 13, ///< $( r1 )  = (strcmp($( r2 ), $( r3 )) <= 0) ? 1 : 0
    OP_CLT   = 14, ///< $( r1 )  = ($( r2 ) < $( r3 )) ? 1 : 0
    OP_CLTF  = 15, ///< $( r1 )  = ($( f2 ) < $( f3 )) ? 1 : 0
    OP_CLTS  = 16, ///< $( r1 )  = (strcmp($( r2 ), $( r3 )) < 0) ? 1 : 0
    OP_CMEQ  = 17, ///< $( r1 )  = ($( r2 ) >= $( r3 )) ? 1 : 0
    OP_CMEQF = 18, ///< $( r1 )  = ($( f2 ) >= $( f3 )) ? 1 : 0
    OP_CMEQS = 19, ///< $( r1 )  = (strcmp($( r2 ), $( r3 )) >= 0) ? 1 : 0
    OP_CMT   = 20, ///< $( r1 )  = ($( r2 ) > $( r3 )) ? 1 : 0
    OP_CMTF  = 21, ///< $( r1 )  = ($( f2 ) > $( f3 )) ? 1 : 0
    OP_CMTS  = 22, ///< $( r1 )  = (strcmp($( r2 ), $( r3 )) > 0) ? 1 : 0
    OP_CVTF  = 23, ///< $( f1 )  = (dfloat)$( r0 )
    OP_CVTI  = 24, ///< $( r1 )  = (dint)$(f0)
    OP_DIV   = 25, ///< $( r1 )  = $( r1 ) / $( r2 )
    OP_DIVF  = 26, ///< $( f1 )  = $( f1 ) / $( f2 )
    OP_DIVI  = 27, ///< $( r )   = $(r) / W_IMMEDIATE(4/2)
    OP_J     = 28, ///< $( pc )  = $(r)
    OP_JCON  = 29, ///< $( pc )  = ($( r2 )) ? $( r1 ) : $( pc )
    OP_JR    = 30, ///< $( pc ) += W_IMMEDIATE(4/2)
    OP_JRCON =
        31, ///< $( pc )  = ($( r1 )) ? $( pc ) + W_IMMEDIATE(4/2) : $( pc )
    OP_LOAD     = 32, ///< $( r1 )  = $( r2 )
    OP_LOADADR  = 33, ///< $( r1 )  = *((dint*)$( r2 ))
    OP_LOADADRB = 34, ///< $( r1 )  = *((uint8_t*)$( r2 ))
    OP_LOADARG  = 35, ///< arg[r1] = $( r2 )
    OP_LOADARGI = 36, ///< arg[r1] = IMMEDIATE(4/2)
    OP_LOADF    = 37, ///< $( f1 )  = $( f2 )
    OP_LOADI    = 38, ///< $( r )   = IMMEDIATE(4/2)
    OP_LOADUI   = 39, ///< $( r )   = IMMEDIATE(4/2) << 32 / 16
    OP_MOD      = 40, ///< $( r1 ) %= $( r2 )
    OP_MODI     = 41, ///< $( r1 ) %= W_IMMEDIATE(4/2)
    OP_MUL      = 42, ///< $( r1 )  = $( r1 ) * $( r2 )
    OP_MULF     = 43, ///< $( f1 )  = $( f1 ) * $( f2 )
    OP_MULI     = 44, ///< $( r )   = $(r) * W_IMMEDIATE(4/2)
    OP_MVTF     = 45, ///< $( f1 )  = $( r0 )
    OP_MVTI     = 46, ///< $( r1 )  = $(f0)
    OP_NOT      = 47, ///< $( r )   = !$(r)
    OP_OR       = 48, ///< $( r1 )  = $( r1 ) | $( r2 )
    OP_ORI      = 49, ///< $( r )  |= IMMEDIATE(4/2)
    OP_POP      = 50, ///< $( r )   = pop(generalStack)
    OP_PUSH     = 51, ///< push(generalStack, $( r ))
    OP_STOADR   = 52, ///< *((dint*)$( r2 )) = $( r1 )
    OP_STOADRB  = 53, ///< *((uint8_t*)$( r2 )) = $( r1 )
    OP_SUB      = 54, ///< $( r1 )  = $( r1 ) - $( r2 )
    OP_SUBF     = 55, ///< $( f1 )  = $( f1 ) - $( f2 )
    OP_SUBI     = 56, ///< $( r )  -= W_IMMEDIATE(4/2)
    OP_SYSCALL  = 57, ///< syscall(IMMEDIATE(1)), see `DSyscall`.
    OP_XOR      = 58, ///< $( r1 )  = $( r1 ) ^ $( r2 )
    OP_XORI     = 59, ///< $( r )  ^= IMMEDIATE(4/2)
} DIns;

/**
 * \def NUM_OPCODES
 * \brief Macro constant representing the number of opcodes.
 */
#define NUM_OPCODES (OP_XORI + 1)

/**
 * \enum _dSyscall
 * \brief The Decision VM Syscall specification.
 *
 * \typedef enum _dSyscall DSyscall
 */
typedef enum _dSyscall {
    SYS_LOADSTR = 0, ///< Load a string value into a MALLOC'D string.
                     ///< * `arg0`: A register which contains a pointer to a
                     ///< MALLOC'D string, the string that is being set.
                     ///< If the new string is a different length, chances are
                     ///< the pointer to the malloc'd string will change, and
                     ///< so will this register.
                     ///< * `arg1`: A register which contains a pointer to the
                     ///< string to copy.

    SYS_PRINT = 1, ///< Print a value to `stdout`.
                   ///< * `arg0`: `0`: `Integer`, `1`: `Float`, `2`: `String`,
                   ///< `3`: `Boolean`.
                   ///< * `arg1`: The register to print.
                   ///< * `arg2`: If set to `1`, it will print a newline at the
                   ///< end, otherwise it will not.
} DSyscall;

/**
 * \def reg_t
 * \brief Macro to represent register indexes.
 *
 * **NOTE:** Needs to be able to hold numbers bigger than the number of
 * registers, since we need to check in code generation if we've used too many.
 */
#define reg_t uint16_t

/**
 * \def VM_NUM_REG
 * \brief Macro constant to state the number of registers in the Decision VM.
 */
#define VM_NUM_REG 256

/**
 * \def VM_NUM_ARG_REG
 * \brief Macro constant to state the number of argument registers.
 */
#define VM_NUM_ARG_REG 4

/**
 * \def VM_REG_FLOAT_START
 * \brief Macro constant to state the starting index of the floating point
 * registers.
 *
 * **NOTE:** There are always 256 general-purpose registers, this constant says
 * where it divides them into integer and floating point registers.
 *
 * **NOTE:** Needs to be < `VM_NUM_REG`!
 */
#define VM_REG_FLOAT_START 128

/**
 * \def VM_IS_FLOAT_REG(reg)
 * \brief Macro to help distinguish floating point registers.
 */
#define VM_IS_FLOAT_REG(reg) ((reg) >= VM_REG_FLOAT_START)

/**
 * \def VM_GENERAL_STACK_CAPACITY
 * \brief Macro constant to state the capacity of the general stack.
 */
#define VM_GENERAL_STACK_CAPACITY 128

/**
 * \def VM_CALL_STACK_CAPACITY
 * \brief Macro constant to state the capacity of the call stack.
 */
#define VM_CALL_STACK_CAPACITY 128

/**
 * \enum _DVM
 * \brief The Decision VM structure.
 *
 * \typedef struct _DVM DVM
 */
typedef struct _DVM {
    char *pc;              ///< The program counter.
    unsigned char _inc_pc; ///< How many bytes to increment the program counter.
                           ///< This is determined automatically.

    dint registers[VM_REG_FLOAT_START]; ///< The general registers.
    dfloat floatRegisters[VM_NUM_REG -
                          VM_REG_FLOAT_START]; ///< The float registers.
    dint argRegisters[VM_NUM_ARG_REG];         ///< The argument registers.

    dint generalStack[VM_GENERAL_STACK_CAPACITY]; ///< The general stack.
    short _generalStackPtr; ///< The general stack pointer.

    char *callStack[VM_CALL_STACK_CAPACITY]; ///< The call stack.
    short _callStackPtr;                     ///< The call stack pointer.

    bool halted;       ///< The halted flag.
    bool runtimeError; ///< The runtime error flag.
} DVM;

/**
 * \def IMMEDIATE_SIZE
 * \brief The size of immediates in bytes.
 *
 * \def immediate_t
 * \brief A type to store immediates in.
 *
 * \def uimmediate_t
 * \brief A type to store unsigned immediates in.
 *
 * \def IMMEDIATE_MASK
 * \brief A mask to get the lower half of an immediate.
 *
 * \def IMMEDIATE_UPPER_MASK
 * \brief A mask to get the upper half of an immediate.
 */
#ifdef DECISION_32
#define IMMEDIATE_SIZE       2
#define immediate_t          int16_t
#define uimmediate_t         uint16_t
#define IMMEDIATE_MASK       0xffff
#define IMMEDIATE_UPPER_MASK 0xffff0000
#else
#define IMMEDIATE_SIZE       4
#define immediate_t          int32_t
#define uimmediate_t         uint32_t
#define IMMEDIATE_MASK       0xffffffff
#define IMMEDIATE_UPPER_MASK 0xffffffff00000000
#endif // DECISION_32

/**
 * \def GET_IMMEDIATE_PTR(ptr)
 * \brief Get a lower immediate value from a pointer.
 */
#define GET_IMMEDIATE_PTR(ptr) (dint) * ((uimmediate_t *)(ptr))

/**
 * \def GET_UPPER_IMMEDIATE_PTR(ptr)
 * \brief Get an upper immediate value from a pointer.
 */
#define GET_UPPER_IMMEDIATE_PTR(ptr) \
    (GET_IMMEDIATE_PTR(ptr) << IMMEDIATE_SIZE * 8)

/**
 * \def GET_BYTEN(ptr, n)
 * \brief Macro function to get the `n`th byte after a pointer `ptr`.
 */
#define GET_BYTEN(ptr, n) *((unsigned char *)(ptr) + (n))

/*
=== FUNCTIONS =============================================
*/

/**
 * \fn const unsigned char d_vm_ins_size(DIns opcode)
 * \brief Given an opcode, get the total size of the instruction involving that
 * opcode in bytes.
 *
 * \return The size of the instruction in bytes. 0 if the opcode doesn't exist.
 *
 * \param opcode The opcode to query.
 */
DECISION_API const unsigned char d_vm_ins_size(DIns opcode);

/**
 * \fn void d_vm_reset(DVM *vm)
 * \brief Reset a Decision VM object to it's starting state.
 *
 * \param vm A Decision VM to set to it's starting state.
 */
DECISION_API void d_vm_reset(DVM *vm);

/**
 * \fn void d_vm_runtime_error(DVM *vm, const char *error)
 * \brief Print a runtime error to `stdout`, and halt the VM.
 *
 * Unlike compiler errors, these errors aren't stored anywhere.
 *
 * \param vm The VM that came across the error.
 * \param error The error message to display.
 */
DECISION_API void d_vm_runtime_error(DVM *vm, const char *error);

/**
 * \def ERROR_RUNTIME(vm, ...)
 * \brief A macro function to be able to print formatted error messages.
 *
 * This is to `d_vm_runtime_error` what `ERROR_COMPILER` is to
 * `d_error_compiler_push`.
 */
#ifdef DECISION_SAFE_FUNCTIONS
#define ERROR_RUNTIME(vm, ...)                          \
    {                                                   \
        char errMsg[MAX_ERROR_SIZE];                    \
        sprintf_s(errMsg, MAX_ERROR_SIZE, __VA_ARGS__); \
        d_vm_runtime_error((vm), errMsg);               \
    }
#else
#define ERROR_RUNTIME(vm, ...)            \
    {                                     \
        char errMsg[MAX_ERROR_SIZE];      \
        sprintf(errMsg, __VA_ARGS__);     \
        d_vm_runtime_error((vm), errMsg); \
    }
#endif // DECISION_SAFE_FUNCTIONS

/**
 * \fn void d_vm_parse_ins_at_pc(DVM *vm)
 * \brief Given a Decision VM, at it's current position in the program, parse
 * the instruction at that position.
 *
 * \param vm The VM to use to parse the instruction.
 */
DECISION_API void d_vm_parse_ins_at_pc(DVM *vm);

/**
 * \fn void d_vm_add_pc(DVM *vm, dint rel)
 * \brief Add to the program counter to go +rel bytes.
 *
 * **NOTE:** The VM will ALWAYS increment the PC after every instruction.
 *
 * \param vm The VM whose PC to add to.
 * \param rel How many bytes to go forward. *Can* be negative.
 */
DECISION_API void d_vm_add_pc(DVM *vm, dint rel);

/**
 * \fn void d_vm_inc_pc(DVM *vm)
 * \brief Increment the program counter in a Decision VM, to go to the next
 * instruction.
 *
 * **NOTE:** The VM will ALWAYS increment the PC after every instruction.
 *
 * \param vm The VM whose PC to add to.
 */
DECISION_API void d_vm_inc_pc(DVM *vm);

/**
 * \fn bool d_vm_run(DVM *vm, void *start)
 * \brief Get a virtual machine to start running instructions in a loop, until
 * it is halted.
 *
 * \return If it ran without any runtime errors.
 *
 * \param vm The VM to run the bytecode in.
 * \param start A pointer to the start of the bytecode to execute.
 */
DECISION_API bool d_vm_run(DVM *vm, void *start);

#endif // DVM_H
