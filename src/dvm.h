/*
    Decision
    Copyright (C) 2019  Benjamin Beddows

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * \file dvm.h
 * \brief This header contains functionality for the Decision VM - the object
 * that will run the generated bytecode.
 */

#ifndef DVM_H
#define DVM_H

#include "dcfg.h"
#include "derror.h"
#include <stdbool.h>

#include <stdint.h>

/*
=== HEADER DEFINITIONS ====================================
*/

/**
 * \enum _dIns
 * \brief The Decision VM Instruction Set.
 *
 * \typedef enum _dIns DIns
 */
typedef enum _dIns {
    OP_RET     = 0,  ///< pop(stackFrame) ELSE halt()
    OP_ADD     = 1,  ///< push(pop() + pop())
    OP_ADDF    = 2,  ///< pushFloat(popFloat() + popFloat())
    OP_ADDBI   = 3,  ///< push(pop() + I(1))
    OP_ADDHI   = 4,  ///< push(pop() + I(|M|/2))
    OP_ADDFI   = 5,  ///< push(pop() + I(|M|))
    OP_AND     = 6,  ///< push(pop() & pop())
    OP_ANDBI   = 7,  ///< push(pop() & I(1))
    OP_ANDHI   = 8,  ///< push(pop() & I(|M|/2))
    OP_ANDFI   = 9,  ///< push(pop() & I(|M|))
    OP_CALL    = 10, ///< pc = pop(); push(stackFrame)
    OP_CALLC   = 11, ///< (*pop())(this)
    OP_CALLCI  = 12, ///< (*I(|M|))(this)
    OP_CALLI   = 13, ///< pc = I(|M|); push(stackFrame)
    OP_CALLR   = 14, ///< pc += pop(); push(stackFrame)
    OP_CALLRB  = 15, ///< pc += I(1); push(stackFrame)
    OP_CALLRH  = 16, ///< pc += I(|M|/2); push(stackFrame)
    OP_CALLRF  = 17, ///< pc += I(|M|); push(stackFrame)
    OP_CEQ     = 18, ///< push(pop() == pop())
    OP_CEQF    = 19, ///< push(popFloat() == popFloat())
    OP_CLEQ    = 20, ///< push(pop() <= pop())
    OP_CLEQF   = 21, ///< push(popFloat() <= popFloat())
    OP_CLT     = 22, ///< push(pop() < pop())
    OP_CLTF    = 23, ///< push(popFloat() < popFloat())
    OP_CMEQ    = 24, ///< push(pop() >= pop())
    OP_CMEQF   = 25, ///< push(popFloat() >= popFloat())
    OP_CMT     = 26, ///< push(pop() > pop())
    OP_CMTF    = 27, ///< push(popFloat() > popFloat())
    OP_CVTF    = 28, ///< push((dfloat)pop())
    OP_CVTI    = 29, ///< push((dint)pop())
    OP_DEREF   = 30, ///< push(*pop())
    OP_DEREFB  = 31, ///< push(*((uint8_t *)pop()))
    OP_DIV     = 32, ///< push(pop() / pop())
    OP_DIVF    = 33, ///< pushFloat(popFloat() / popFloat())
    OP_DIVBI   = 34, ///< push(pop() / I(1))
    OP_DIVHI   = 35, ///< push(pop() / I(|M|/2))
    OP_DIVFI   = 36, ///< push(pop() / I(|M|))
    OP_GET     = 37, ///< push(get(pop()))
    OP_GETBI   = 38, ///< push(get(I(1)))
    OP_GETHI   = 39, ///< push(get(I(|M|/2)))
    OP_GETFI   = 40, ///< push(get(I(|M|)))
    OP_J       = 41, ///< pc = pop()
    OP_JCON    = 42, ///< IF pop() THEN pc = pop() ELSE pop()
    OP_JCONI   = 43, ///< IF pop() THEN pc = I(|M|)
    OP_JI      = 44, ///< pc = I(|M|)
    OP_JR      = 45, ///< pc += pop()
    OP_JRBI    = 46, ///< pc += I(1)
    OP_JRHI    = 47, ///< pc += I(|M|/2)
    OP_JRFI    = 48, ///< pc += I(|M|)
    OP_JRCON   = 49, ///< IF pop() THEN pc += pop() ELSE pop()
    OP_JRCONBI = 50, ///< IF pop() THEN pc += I(1)
    OP_JRCONHI = 51, ///< IF pop() THEN pc += I(|M|/2)
    OP_JRCONFI = 52, ///< IF pop() THEN pc += I(|M|)
    OP_MOD     = 53, ///< push(pop() % pop())
    OP_MODBI   = 54, ///< push(pop() % I(1))
    OP_MODHI   = 55, ///< push(pop() % I(|M|/2))
    OP_MODFI   = 56, ///< push(pop() % I(|M|))
    OP_MUL     = 57, ///< push(pop() * pop())
    OP_MULF    = 58, ///< pushFloat(popFloat() * popFloat())
    OP_MULBI   = 59, ///< push(pop() * I(1))
    OP_MULHI   = 60, ///< push(pop() * I(|M|/2))
    OP_MULFI   = 61, ///< push(pop() * I(|M|))
    OP_NOT     = 62, ///< push(!pop())
    OP_OR      = 63, ///< push(pop() | pop())
    OP_ORBI    = 64, ///< push(pop() | I(1))
    OP_ORHI    = 65, ///< push(pop() | I(|M|/2))
    OP_ORFI    = 66, ///< push(pop() | I(|M|))
    OP_POPB    = 67, ///< pop() I(1) times
    OP_POPH    = 68, ///< pop() I(|M|/2) times
    OP_POPF    = 69, ///< pop() I(|M|) times
    OP_PUSHB   = 70, ///< push(I(1))
    OP_PUSHH   = 71, ///< push(I(|M|/2))
    OP_PUSHF   = 72, ///< push(I(|M|))
    OP_SETADR  = 73, ///< *((dint *)pop()) = pop()
    OP_SETADRB = 74, ///< *((uint8_t *)pop()) = pop()
    OP_SUB     = 75, ///< push(pop() - pop())
    OP_SUBF    = 76, ///< pushFloat(popFloat() - popFloat())
    OP_SUBBI   = 77, ///< push(pop() - I(1))
    OP_SUBHI   = 78, ///< push(pop() - I(|M|/2))
    OP_SUBFI   = 79, ///< push(pop() - I(|M|))
    OP_SYSCALL = 80, ///< push(syscall(I(1), pop(), pop(), pop()))
    OP_XOR     = 81, ///< push(pop() ^ pop())
    OP_XORBI   = 82, ///< push(pop() ^ I(1))
    OP_XORHI   = 83, ///< push(pop() ^ I(|M|/2))
    OP_XORFI   = 84, ///< push(pop() ^ I(|M|))
} DIns;

/**
 * \def NUM_OPCODES
 * \brief Macro constant representing the number of opcodes.
 */
#define NUM_OPCODES (OP_XORFI + 1)

/**
 * \enum _dSyscall
 * \brief The Decision VM Syscall specification.
 *
 * \typedef enum _dSyscall DSyscall
 */
typedef enum _dSyscall {
    SYS_PRINT = 0, ///< Print a value to `stdout`.
                   ///< * `arg0`: `0`: `Integer`, `1`: `Float`, `2`: `String`,
                   ///< `3`: `Boolean`.
                   ///< * `arg1`: The value to print.
                   ///< * `arg2`: If set to `1`, it will print a newline at the
                   ///< end, otherwise it will not.
                   ///< * Returns: The value 0.
} DSyscall;

/**
 * \def VM_STACK_SIZE_MIN
 * \brief The minimum, and starting, size of the VM's stack.
 */
#define VM_STACK_SIZE_MIN 64

/**
 * \def VM_STACK_SIZE_SCALE_INC
 * \brief How much should the stack size increase once it reaches capacity?
 */
#define VM_STACK_SIZE_SCALE_INC 1.5

/**
 * \def VM_STACK_SIZE_SCALE_DEC
 * \brief How much should the stack size decrease to save memory?
 */
#define VM_STACK_SIZE_SCALE_DEC 0.5

/**
 * \enum _DVM
 * \brief The Decision VM structure.
 *
 * \typedef struct _DVM DVM
 */
typedef struct _DVM {
    char *pc;              ///< The program counter.
    unsigned char _inc_pc; ///< How many bytes to increment the program counter.
                           ///< This is determined automatically.

    dint *basePtr;  ///< A pointer to the base of the stack.
    dint *stackPtr; ///< A pointer to the top of the stack.
    dint *framePtr; ///< A pointer to the start of the stack frame.

    duint stackSize; ///< The current size of the stack.

    bool halted;       ///< The halted flag.
    bool runtimeError; ///< The runtime error flag.
} DVM;

#define BIMMEDIATE_SIZE 1
#define bimmediate_t    int8_t

#ifdef DECISION_32
#define HIMMEDIATE_SIZE 2
#define himmediate_t    int16_t
#define FIMMEDIATE_SIZE 4
#define fimmediate_t    int32_t
#else
#define HIMMEDIATE_SIZE 4
#define himmediate_t    int32_t
#define FIMMEDIATE_SIZE 8
#define fimmediate_t    int64_t
#endif // DECISION_32

/*
=== STACK FUNCTIONS =======================================
*/

/**
 * \fn dint d_vm_get(DVM *vm, dint index)
 * \brief Get an integer from a value in the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \return The integer value of the stack at the given index.
 *
 * \param vm The VM whose stack to retrieve from.
 * \param index The index of the stack.
 */
DECISION_API dint d_vm_get(DVM *vm, dint index);

/**
 * \fn dfloat d_vm_get_float(DVM *vm, dint index)
 * \brief Get a float from a value in the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \return The float value of the stack at the given index.
 *
 * \param vm The VM whose stack to retrieve from.
 * \param index The index of the stack.
 */
DECISION_API dfloat d_vm_get_float(DVM *vm, dint index);

/**
 * \fn void *d_vm_get_float(DVM *vm, dint index)
 * \brief Get a pointer from a value in the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \return The pointer value of the stack at the given index.
 *
 * \param vm The VM whose stack to retrieve from.
 * \param index The index of the stack.
 */
DECISION_API void *d_vm_get_ptr(DVM *vm, dint index);

/**
 * \fn void d_vm_insert(DVM *vm, dint index, dint value)
 * \brief Insert an integer into the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to insert to.
 * \param index The index of the stack to insert to, i.e. `value` will be at
 * this location when the function returns.
 * \param value The value to insert into the stack.
 */
DECISION_API void d_vm_insert(DVM *vm, dint index, dint value);

/**
 * \fn void d_vm_insert_float(DVM *vm, dint index, dfloat value)
 * \brief Insert a float into the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to insert to.
 * \param index The index of the stack to insert to, i.e. `value` will be at
 * this location when the function returns.
 * \param value The value to insert into the stack.
 */
DECISION_API void d_vm_insert_float(DVM *vm, dint index, dfloat value);

/**
 * \fn void d_vm_insert_ptr(DVM *vm, dint index, void *ptr)
 * \brief Insert a pointer into the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to insert to.
 * \param index The index of the stack to insert to, i.e. `ptr` will be at this
 * location when the function returns.
 * \param value The pointer to insert into the stack.
 */
DECISION_API void d_vm_insert_ptr(DVM *vm, dint index, void *ptr);

/**
 * \fn dint d_vm_pop(DVM *vm)
 * \brief Pop an integer from the top of the stack.
 *
 * \return The integer at the top of the stack.
 *
 * \param vm The VM whose stack to pop from.
 */
DECISION_API dint d_vm_pop(DVM *vm);

/**
 * \fn void d_vm_popn(DVM *vm, size_t n)
 * \brief Pop `n` elements from the stack.
 *
 * \param vm The VM whose stack to pop from.
 * \param n The number of elements to pop.
 */
DECISION_API void d_vm_popn(DVM *vm, size_t n);

/**
 * \fn dfloat d_vm_pop_float(DVM *vm)
 * \brief Pop a float from the top of the stack.
 *
 * \return The float at the top of the stack.
 *
 * \param vm The VM whose stack to pop from.
 */
DECISION_API dfloat d_vm_pop_float(DVM *vm);

/**
 * \fn void *d_vm_pop_ptr(DVM *vm)
 * \brief Pop a pointer from the top of the stack.
 *
 * \return The pointer at the top of the stack.
 *
 * \param vm The VM whose stack to pop from.
 */
DECISION_API void *d_vm_pop_ptr(DVM *vm);

/**
 * \fn void d_vm_push(DVM *vm, dint value)
 * \brief Push an integer value onto the stack.
 *
 * \param vm The VM whose stack to push onto.
 * \param value The value to push onto the stack.
 */
DECISION_API void d_vm_push(DVM *vm, dint value);

/**
 * \fn void d_vm_push_float(DVM *vm, dfloat value)
 * \brief Push a float value onto the stack.
 *
 * \param vm The VM whose stack to push onto.
 * \param value The value to push onto the stack.
 */
DECISION_API void d_vm_push_float(DVM *vm, dfloat value);

/**
 * \fn void d_vm_push_ptr(DVM *vm, void *ptr)
 * \brief Push a pointer onto the stack.
 *
 * \param vm The VM whose stack to push onto.
 * \param ptr The pointer to push onto the stack.
 */
DECISION_API void d_vm_push_ptr(DVM *vm, void *ptr);

/**
 * \fn void d_vm_remove(DVM *vm, dint index)
 * \brief Remove the value from the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to remove from.
 * \param index The index to remove from the stack.
 */
DECISION_API void d_vm_remove(DVM *vm, dint index);

/**
 * \fn void d_vm_remove_len(DVM *vm, dint index, size_t len)
 * \brief Remove a number of values from the stack, starting at a particular
 * index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to remove from.
 * \param index The index to start removing from the stack.
 * \param len The number of items to remove from the stack.
 */
DECISION_API void d_vm_remove_len(DVM *vm, dint index, size_t len);

/**
 * \fn void d_vm_set(DVM *vm, dint index, dint value)
 * \brief Set the value of an element in the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to set the element of.
 * \param index The index of the stack.
 * \param value The value to set.
 */
DECISION_API void d_vm_set(DVM *vm, dint index, dint value);

/**
 * \fn void d_vm_set_float(DVM *vm, dint index, dfloat value)
 * \brief Set the value of an element in the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to set the element of.
 * \param index The index of the stack.
 * \param value The value to set.
 */
DECISION_API void d_vm_set_float(DVM *vm, dint index, dfloat value);

/**
 * \fn void d_vm_set_ptr(DVM *vm, dint index, void *ptr)
 * \brief Set the value of an element in the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to set the element of.
 * \param index The index of the stack.
 * \param ptr The value to set.
 */
DECISION_API void d_vm_set_ptr(DVM *vm, dint index, void *ptr);

/**
 * \fn size_t d_vm_top(DVM *vm)
 * \brief Get the number of elements in the stack.
 *
 * \return The number of elements in the stack.
 *
 * \param vm The VM whose stack to query.
 */
DECISION_API size_t d_vm_top(DVM *vm);

/*
=== VM FUNCTIONS ==========================================
*/

/**
 * \fn const unsigned char d_vm_ins_size(DIns opcode)
 * \brief Given an opcode, get the total size of the instruction involving that
 * opcode in bytes.
 *
 * \return The size of the instruction in bytes. 0 if the opcode doesn't exist.
 *
 * \param opcode The opcode to query.
 */
DECISION_API const unsigned char d_vm_ins_size(DIns opcode);

/**
 * \fn DVM d_vm_create()
 * \brief Create a Decision VM in its starting state, with malloc'd elements.
 *
 * \return A Decision VM in its starting state.
 */
DECISION_API DVM d_vm_create();

/**
 * \fn void d_vm_reset(DVM *vm)
 * \brief Reset a Decision VM to its starting state.
 *
 * \param vm A Decision VM to set to its starting state.
 */
DECISION_API void d_vm_reset(DVM *vm);

/**
 * \fn void d_vm_free(DVM *vm)
 * \brief Free the malloc'd elements of a Decision VM. Note that this makes the
 * VM unusable unless you call `d_vm_reset` on it.
 *
 * \param vm The Decision VM to free.
 */
DECISION_API void d_vm_free(DVM *vm);

/**
 * \fn void d_vm_runtime_error(DVM *vm, const char *error)
 * \brief Print a runtime error to `stdout`, and halt the VM.
 *
 * Unlike compiler errors, these errors aren't stored anywhere.
 *
 * \param vm The VM that came across the error.
 * \param error The error message to display.
 */
DECISION_API void d_vm_runtime_error(DVM *vm, const char *error);

/**
 * \def ERROR_RUNTIME(vm, ...)
 * \brief A macro function to be able to print formatted error messages.
 *
 * This is to `d_vm_runtime_error` what `ERROR_COMPILER` is to
 * `d_error_compiler_push`.
 */
#ifdef DECISION_SAFE_FUNCTIONS
#define ERROR_RUNTIME(vm, ...)                          \
    {                                                   \
        char errMsg[MAX_ERROR_SIZE];                    \
        sprintf_s(errMsg, MAX_ERROR_SIZE, __VA_ARGS__); \
        d_vm_runtime_error((vm), errMsg);               \
    }
#else
#define ERROR_RUNTIME(vm, ...)            \
    {                                     \
        char errMsg[MAX_ERROR_SIZE];      \
        sprintf(errMsg, __VA_ARGS__);     \
        d_vm_runtime_error((vm), errMsg); \
    }
#endif // DECISION_SAFE_FUNCTIONS

/**
 * \fn void d_vm_parse_ins_at_pc(DVM *vm)
 * \brief Given a Decision VM, at it's current position in the program, parse
 * the instruction at that position.
 *
 * \param vm The VM to use to parse the instruction.
 */
// DECISION_API void d_vm_parse_ins_at_pc(DVM *vm);

/**
 * \fn void d_vm_add_pc(DVM *vm, dint rel)
 * \brief Add to the program counter to go +rel bytes.
 *
 * **NOTE:** The VM will ALWAYS increment the PC after any instruction that
 * isn't a jump, call or return.
 *
 * \param vm The VM whose PC to add to.
 * \param rel How many bytes to go forward. *Can* be negative.
 */
DECISION_API void d_vm_add_pc(DVM *vm, dint rel);

/**
 * \fn void d_vm_inc_pc(DVM *vm)
 * \brief Increment the program counter in a Decision VM, to go to the next
 * instruction.
 *
 * **NOTE:** The VM will ALWAYS increment the PC after any instruction that
 * isn't a jump, call or return.
 *
 * \param vm The VM whose PC to add to.
 */
DECISION_API void d_vm_inc_pc(DVM *vm);

/**
 * \fn bool d_vm_run(DVM *vm, void *start)
 * \brief Get a virtual machine to start running instructions in a loop, until
 * it is halted.
 *
 * \return If it ran without any runtime errors.
 *
 * \param vm The VM to run the bytecode in.
 * \param start A pointer to the start of the bytecode to execute.
 */
DECISION_API bool d_vm_run(DVM *vm, void *start);

/**
 * \fn void d_vm_dump(DVM *vm)
 * \brief Dump the contents of a Decision VM to stdout for debugging.
 *
 * \param vm The VM to dump the contents of.
 */
DECISION_API void d_vm_dump(DVM *vm);

#endif // DVM_H
