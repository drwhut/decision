/*
    Decision
    Copyright (C) 2019-2020  Benjamin Beddows

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * \file dvm.h
 * \brief This header contains functionality for the Decision VM - the object
 * that will run the generated bytecode.
 */

#ifndef DVM_H
#define DVM_H

#include "dcfg.h"
#include "derror.h"
#include <stdbool.h>

#include <stdint.h>

/*
=== HEADER DEFINITIONS ====================================
*/

/**
 * \enum _dIns
 * \brief The Decision VM Instruction Set.
 *
 * \typedef enum _dIns DIns
 */
typedef enum _dIns {
    OP_RET     = 0,  ///< Equivalent to RETN 0.
    OP_RETN    = 1,  ///< pop(stackFrame w/ I(1) return values)
    OP_ADD     = 2,  ///< push(pop() + pop())
    OP_ADDBI   = 3,  ///< push(pop() + I(1))
    OP_ADDHI   = 4,  ///< push(pop() + I(|M|/2))
    OP_ADDFI   = 5,  ///< push(pop() + I(|M|))
    OP_AND     = 6,  ///< push(pop() & pop())
    OP_ANDBI   = 7,  ///< push(pop() & I(1))
    OP_ANDHI   = 8,  ///< push(pop() & I(|M|/2))
    OP_ANDFI   = 9,  ///< push(pop() & I(|M|))
    OP_CALL    = 10, ///< pc = popPtr(); push(stackFrame w/ I(1) arguments)
    OP_CALLC   = 11, ///< (*popPtr())(this) w/ I(1) arguments
    OP_CALLCI  = 12, ///< (*I(|M|))(this) w/ I(1) arguments
    OP_CALLI   = 13, ///< pc = I(|M|); push(stackFrame w/ I(1) arguments)
    OP_CALLR   = 14, ///< pc += popInt(); push(stackFrame w/ I(1) arguments)
    OP_CALLRB  = 15, ///< pc += I(1); push(stackFrame w/ I(1) arguments)
    OP_CALLRH  = 16, ///< pc += I(|M|/2); push(stackFrame w/ I(1) arguments)
    OP_CALLRF  = 17, ///< pc += I(|M|); push(stackFrame w/ I(1) arguments)
    OP_CEQ     = 18, ///< pushBool(pop() == pop())
    OP_CLEQ    = 19, ///< pushBool(pop() <= pop())
    OP_CLT     = 20, ///< pushBool(pop() < pop())
    OP_CMEQ    = 21, ///< pushBool(pop() >= pop())
    OP_CMT     = 22, ///< pushBool(pop() > pop())
    OP_CVTF    = 23, ///< pushFloat((dfloat)pop())
    OP_CVTI    = 24, ///< pushInt((dint)pop())
    OP_DEREF   = 25, ///< push(*(StackEntry *)popPtr())
    OP_DEREFI  = 26, ///< push(*(StackEntry *)I(|M|))
    OP_DIV     = 27, ///< pushFloat(pop() / pop())
    OP_DIVBI   = 28, ///< pushFloat(pop() / I(1))
    OP_DIVHI   = 29, ///< pushFloat(pop() / I(|M|/2))
    OP_DIVFI   = 30, ///< pushFloat(pop() / I(|M|))
    OP_GET     = 31, ///< push(get(popInt()))
    OP_GETBI   = 32, ///< push(get(I(1)))
    OP_GETHI   = 33, ///< push(get(I(|M|/2)))
    OP_GETFI   = 34, ///< push(get(I(|M|)))
    OP_INV     = 35, ///< pushInt(~popInt())
    OP_J       = 36, ///< pc = popPtr()
    OP_JCON    = 37, ///< IF popBool() THEN pc = popPtr() ELSE popPtr()
    OP_JCONI   = 38, ///< IF popBool() THEN pc = I(|M|)
    OP_JI      = 39, ///< pc = I(|M|)
    OP_JR      = 40, ///< pc += popInt()
    OP_JRBI    = 41, ///< pc += I(1)
    OP_JRHI    = 42, ///< pc += I(|M|/2)
    OP_JRFI    = 43, ///< pc += I(|M|)
    OP_JRCON   = 44, ///< IF popBool() THEN pc += popInt() ELSE popInt()
    OP_JRCONBI = 45, ///< IF popBool() THEN pc += I(1)
    OP_JRCONHI = 46, ///< IF popBool() THEN pc += I(|M|/2)
    OP_JRCONFI = 47, ///< IF popBool() THEN pc += I(|M|)
    OP_MARK    = 48, ///< Mark the value at the top of the stack to be freed
                     ///< when the VM pops it.
    OP_MOD     = 49, ///< pushInt(popInt() % popInt())
    OP_MODBI   = 50, ///< pushInt(popInt() % I(1))
    OP_MODHI   = 51, ///< pushInt(popInt() % I(|M|/2))
    OP_MODFI   = 52, ///< pushInt(popInt() % I(|M|))
    OP_MUL     = 53, ///< push(pop() * pop())
    OP_MULBI   = 54, ///< push(pop() * I(1))
    OP_MULHI   = 55, ///< push(pop() * I(|M|/2))
    OP_MULFI   = 56, ///< push(pop() * I(|M|))
    OP_NOT     = 57, ///< pushBool(!popBool())
    OP_OR      = 58, ///< push(pop() | pop())
    OP_ORBI    = 59, ///< push(pop() | I(1))
    OP_ORHI    = 60, ///< push(pop() | I(|M|/2))
    OP_ORFI    = 61, ///< push(pop() | I(|M|))
    OP_POP     = 62, ///< pop() once
    OP_POPB    = 63, ///< pop() I(1) times
    OP_POPH    = 64, ///< pop() I(|M|/2) times
    OP_POPF    = 65, ///< pop() I(|M|) times
    OP_PUSHIB  = 66, ///< pushInt(I(1))
    OP_PUSHIH  = 67, ///< pushInt(I(|M|/2))
    OP_PUSHIF  = 68, ///< pushInt(I(|M|))
    OP_PUSHF   = 69, ///< pushFloat(I(|M|))
    OP_PUSHS   = 70, ///< pushString(I(|M|))
    OP_PUSHB   = 71, ///< pushBool(I(1))
    OP_PUSHP   = 72, ///< pushPtr(I(|M|))
    OP_PUSHNB  = 73, ///< push(0) I(1) times
    OP_PUSHNH  = 74, ///< push(0) I(|M|/2) times
    OP_PUSHNF  = 75, ///< push(0) I(|M|) times
    OP_SETADR  = 76, ///< *((StackEntry *)popPtr()) = pop()
    OP_SETADRI = 77, ///< *((StackEntry *)I(|M|)) = pop()
    OP_SUB     = 78, ///< push(pop() - pop())
    OP_SUBBI   = 79, ///< push(pop() - I(1))
    OP_SUBHI   = 80, ///< push(pop() - I(|M|/2))
    OP_SUBFI   = 81, ///< push(pop() - I(|M|))
    OP_SYSCALL = 82, ///< push(syscall(I(1), pop(), pop()))
    OP_XOR     = 83, ///< push(pop() ^ pop())
    OP_XORBI   = 84, ///< push(pop() ^ I(1))
    OP_XORHI   = 85, ///< push(pop() ^ I(|M|/2))
    OP_XORFI   = 86, ///< push(pop() ^ I(|M|))
} DIns;

/**
 * \def NUM_OPCODES
 * \brief Macro constant representing the number of opcodes.
 */
#define NUM_OPCODES (OP_XORFI + 1)

/**
 * \enum _dSyscall
 * \brief The Decision VM Syscall specification.
 *
 * \typedef enum _dSyscall DSyscall
 */
typedef enum _dSyscall {
    SYS_PRINT = 0, ///< Print a value to `stdout`.
                   ///< * `arg1` (Boolean): Print a newline after?
                   ///< * `arg2` (Any): The value to print.
                   ///< * Returns (None): The value 0.

    SYS_STRCMP = 1, ///< Compare two strings.
                    ///< * `arg1` (String): The first string pointer.
                    ///< * `arg2` (String): The second string pointer.
                    ///< * Returns (Integer): 1 if `arg1` > `arg2`, -1 if `arg1`
                    ///< < `arg2`, and 0 otherwise.

    SYS_STRLEN = 2, ///< Get the length of a string.
                    ///< * `arg1`: Unused.
                    ///< * `arg2` (String): The string to get the length of.
                    ///< * Returns (Integer): The length of the string.
} DSyscall;

/**
 * \def VM_STACK_SIZE_MIN
 * \brief The minimum, and starting, size of the VM's stack.
 */
#define VM_STACK_SIZE_MIN 16

/**
 * \def VM_STACK_SIZE_SCALE_INC
 * \brief How much should the stack size increase once it reaches capacity?
 */
#define VM_STACK_SIZE_SCALE_INC 1.5

/**
 * \def VM_STACK_SIZE_SCALE_DEC
 * \brief How much should the stack size decrease to save memory?
 */
#define VM_STACK_SIZE_SCALE_DEC 0.5

/**
 * \struct _stackEntry
 * \brief A entry in the VM stack which contains some data, and the data type
 * of that data.
 *
 * \typedef struct _stackEntry StackEntry
 */
typedef struct _stackEntry {
    union {
        dint i;
        dfloat f;
        void *p;
        bool b;
    } data;       ///< The data in the entry.
    uint8_t type; ///< The data type of the entry.

    bool free; ///< When this entry is poped from the stack, should the pointer
               ///< be freed?
} StackEntry;

/**
 * \enum _DVM
 * \brief The Decision VM structure.
 *
 * \typedef struct _DVM DVM
 */
typedef struct _DVM {
    char *pc; ///< The program counter.

    StackEntry *basePtr;  ///< A pointer to the base of the stack.
    StackEntry *stackPtr; ///< A pointer to the top of the stack.
    StackEntry *framePtr; ///< A pointer to the start of the stack frame.

    duint stackSize; ///< The current size of the stack.

    unsigned char _inc_pc; ///< How many bytes to increment the program counter.
                           ///< This is determined automatically.

    bool halted;       ///< The halted flag.
    bool runtimeError; ///< The runtime error flag.
} DVM;

#define BIMMEDIATE_SIZE   1
#define bimmediate_t      int8_t
#define BIMMEDIATE_MIN    INT8_MIN
#define BIMMEDIATE_MAX    INT8_MAX
#define BIMMEDIATE_PRINTF "hh"

#ifdef DECISION_32
#define HIMMEDIATE_SIZE 2
#define himmediate_t    int16_t
#define HIMMEDIATE_MIN  INT16_MIN
#define HIMMEDIATE_MAX  INT16_MAX
#define FIMMEDIATE_SIZE 4
#define fimmediate_t    int32_t
#define FIMMEDIATE_MIN  INT32_MIN
#define FIMMEDIATE_MAX  INT32_MAX

#if defined(WIN32)
#define HIMMEDIATE_PRINTF "h"
#define FIMMEDIATE_PRINTF "l"
#else
#define HIMMEDIATE_PRINTF "hh"
#define FIMMEDIATE_PRINTF "h"
#endif // defined(WIN32)

#else // 64-bit.
#define HIMMEDIATE_SIZE 4
#define himmediate_t    int32_t
#define HIMMEDIATE_MIN  INT32_MIN
#define HIMMEDIATE_MAX  INT32_MAX
#define FIMMEDIATE_SIZE 8
#define fimmediate_t    int64_t
#define FIMMEDIATE_MIN  INT64_MIN
#define FIMMEDIATE_MAX  INT64_MAX

#if defined(WIN32)
#define HIMMEDIATE_PRINTF "l"
#define FIMMEDIATE_PRINTF "ll"
#else
#define HIMMEDIATE_PRINTF "h"
#define FIMMEDIATE_PRINTF "l"
#endif // defined(WIN32)
#endif // DECISION_32

/*
=== STACK FUNCTIONS =======================================
*/

/**
 * \fn size_t d_vm_frame(DVM *vm)
 * \brief Get the number of elements in the current stack frame.
 *
 * \return The number of elements in the stack frame.
 *
 * \param vm The VM whose stack to query.
 */
DECISION_API size_t d_vm_frame(DVM *vm);

/**
 * \fn dint d_vm_get_int(DVM *vm, dint index)
 * \brief Get an integer from a value in the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \return The integer value of the stack at the given index.
 *
 * \param vm The VM whose stack to retrieve from.
 * \param index The index of the stack.
 */
DECISION_API dint d_vm_get_int(DVM *vm, dint index);

/**
 * \fn dfloat d_vm_get_float(DVM *vm, dint index)
 * \brief Get a float from a value in the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \return The float value of the stack at the given index.
 *
 * \param vm The VM whose stack to retrieve from.
 * \param index The index of the stack.
 */
DECISION_API dfloat d_vm_get_float(DVM *vm, dint index);

/**
 * \fn void *d_vm_get_ptr(DVM *vm, dint index)
 * \brief Get a pointer from a value in the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \return The pointer value of the stack at the given index.
 *
 * \param vm The VM whose stack to retrieve from.
 * \param index The index of the stack.
 */
DECISION_API void *d_vm_get_ptr(DVM *vm, dint index);

/**
 * \fn bool d_vm_get_bool(DVM *vm, dint index)
 * \brief Get a boolean from a value in the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \return The boolean value of the stack at the given index.
 *
 * \param vm The VM whose stack to retrieve from.
 * \param index The index of the stack.
 */
DECISION_API bool d_vm_get_bool(DVM *vm, dint index);

/**
 * \fn void d_vm_insert_int(DVM *vm, dint index, dint value)
 * \brief Insert an integer into the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to insert to.
 * \param index The index of the stack to insert to, i.e. `value` will be at
 * this location when the function returns.
 * \param value The value to insert into the stack.
 */
DECISION_API void d_vm_insert_int(DVM *vm, dint index, dint value);

/**
 * \fn void d_vm_insert_float(DVM *vm, dint index, dfloat value)
 * \brief Insert a float into the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to insert to.
 * \param index The index of the stack to insert to, i.e. `value` will be at
 * this location when the function returns.
 * \param value The value to insert into the stack.
 */
DECISION_API void d_vm_insert_float(DVM *vm, dint index, dfloat value);

/**
 * \fn void d_vm_insert_str(DVM *vm, dint index, char *str, bool mark)
 * \brief Insert a string into the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to insert to.
 * \param index The index of the stack to insert to, i.e. `str` will be at this
 * location when the function returns.
 * \param str The string to insert into the stack.
 * \param mark Mark this string to be freed when it is poped from the stack by
 * the VM.
 */
DECISION_API void d_vm_insert_str(DVM *vm, dint index, char *str, bool mark);

/**
 * \fn void d_vm_insert_bool(DVM *vm, dint index, bool value)
 * \brief Insert a boolean into the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to insert to.
 * \param index The index of the stack to insert to, i.e. `value` will be at
 * this location when the function returns.
 * \param value The value to insert into the stack.
 */
DECISION_API void d_vm_insert_bool(DVM *vm, dint index, bool value);

/**
 * \fn void d_vm_popn(DVM *vm, size_t n)
 * \brief Pop `n` elements from the stack.
 *
 * \param vm The VM whose stack to pop from.
 * \param n The number of elements to pop.
 */
DECISION_API void d_vm_popn(DVM *vm, size_t n);

/**
 * \fn dint d_vm_pop_int(DVM *vm)
 * \brief Pop an integer from the top of the stack.
 *
 * \return The integer at the top of the stack.
 *
 * \param vm The VM whose stack to pop from.
 */
DECISION_API dint d_vm_pop_int(DVM *vm);

/**
 * \fn dfloat d_vm_pop_float(DVM *vm)
 * \brief Pop a float from the top of the stack.
 *
 * \return The float at the top of the stack.
 *
 * \param vm The VM whose stack to pop from.
 */
DECISION_API dfloat d_vm_pop_float(DVM *vm);

/**
 * \fn void *d_vm_pop_ptr(DVM *vm)
 * \brief Pop a pointer from the top of the stack.
 *
 * \return The pointer at the top of the stack.
 *
 * \param vm The VM whose stack to pop from.
 */
DECISION_API void *d_vm_pop_ptr(DVM *vm);

/**
 * \fn bool d_vm_pop_bool(DVM *vm)
 * \brief Pop a boolean from the top of the stack.
 *
 * \return The boolean at the top of the stack.
 *
 * \param vm The VM whose stack to pop from.
 */
DECISION_API bool d_vm_pop_bool(DVM *vm);

/**
 * \fn void d_vm_pushn(DVM *vm, size_t n)
 * \brief Push `0` onto the stack `n` times. The new entries will not have any
 * type associated with them.
 *
 * \param vm The VM whose stack to push onto.
 * \param n The number of items to push onto the stack.
 */
DECISION_API void d_vm_pushn(DVM *vm, size_t n);

/**
 * \fn void d_vm_push_int(DVM *vm, dint value)
 * \brief Push an integer value onto the stack.
 *
 * \param vm The VM whose stack to push onto.
 * \param value The value to push onto the stack.
 */
DECISION_API void d_vm_push_int(DVM *vm, dint value);

/**
 * \fn void d_vm_push_float(DVM *vm, dfloat value)
 * \brief Push a float value onto the stack.
 *
 * \param vm The VM whose stack to push onto.
 * \param value The value to push onto the stack.
 */
DECISION_API void d_vm_push_float(DVM *vm, dfloat value);

/**
 * \fn void d_vm_push_str(DVM *vm, char *str, bool mark)
 * \brief Push a string onto the stack.
 *
 * \param vm The VM whose stack to push onto.
 * \param ptr The string to push onto the stack.
 * \param mark Mark this string to be freed when it is poped from the stack by
 * the VM.
 */
DECISION_API void d_vm_push_str(DVM *vm, char *str, bool mark);

/**
 * \fn void d_vm_push_bool(DVM *vm, bool value)
 * \brief Push a boolean value onto the stack.
 *
 * \param vm The VM whose stack to push onto.
 * \param value The value to push onto the stack.
 */
DECISION_API void d_vm_push_bool(DVM *vm, bool value);

/**
 * \fn void d_vm_remove(DVM *vm, dint index)
 * \brief Remove the value from the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to remove from.
 * \param index The index to remove from the stack.
 */
DECISION_API void d_vm_remove(DVM *vm, dint index);

/**
 * \fn void d_vm_remove_len(DVM *vm, dint index, size_t len)
 * \brief Remove a number of values from the stack, starting at a particular
 * index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to remove from.
 * \param index The index to start removing from the stack.
 * \param len The number of items to remove from the stack.
 */
DECISION_API void d_vm_remove_len(DVM *vm, dint index, size_t len);

/**
 * \fn void d_vm_set_int(DVM *vm, dint index, dint value)
 * \brief Set the value of an element in the stack at a particular index to be
 * a given integer.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to set the element of.
 * \param index The index of the stack.
 * \param value The integer value to set.
 */
DECISION_API void d_vm_set_int(DVM *vm, dint index, dint value);

/**
 * \fn void d_vm_set_float(DVM *vm, dint index, dfloat value)
 * \brief Set the value of an element in the stack at a particular index to be
 * a given float.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to set the element of.
 * \param index The index of the stack.
 * \param value The float value to set.
 */
DECISION_API void d_vm_set_float(DVM *vm, dint index, dfloat value);

/**
 * \fn void d_vm_set_str(DVM *vm, dint index, char *str, bool mark)
 * \brief Set the value of an element in the stack at a particular index to be
 * a given string.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to set the element of.
 * \param index The index of the stack.
 * \param str The string value to set.
 * \param mark Mark this string to be freed when it is poped from the stack by
 * the VM.
 */
DECISION_API void d_vm_set_str(DVM *vm, dint index, char *str, bool mark);

/**
 * \fn void d_vm_set_bool(DVM *vm, dint index, bool value)
 * \brief Set the value of an element in the stack at a particular index to be
 * a given boolean.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \param vm The VM whose stack to set the element of.
 * \param index The index of the stack.
 * \param value The boolean value to set.
 */
DECISION_API void d_vm_set_bool(DVM *vm, dint index, bool value);

/**
 * \fn size_t d_vm_top(DVM *vm)
 * \brief Get the number of elements in the stack.
 *
 * \return The number of elements in the stack.
 *
 * \param vm The VM whose stack to query.
 */
DECISION_API size_t d_vm_top(DVM *vm);

/**
 * \fn DType d_vm_type(DVM *vm, dint index)
 * \brief Get the type of the stack element at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \return The type of the stack element at the given index.
 *
 * \param vm The VM whose stack to get the element from.
 * \param index The index of the stack.
 */
DECISION_API DType d_vm_type(DVM *vm, dint index);

/*
=== VM FUNCTIONS ==========================================
*/

/**
 * \fn unsigned char d_vm_ins_size(DIns opcode)
 * \brief Given an opcode, get the total size of the instruction involving that
 * opcode in bytes.
 *
 * \return The size of the instruction in bytes. 0 if the opcode doesn't exist.
 *
 * \param opcode The opcode to query.
 */
DECISION_API unsigned char d_vm_ins_size(DIns opcode);

/**
 * \fn DVM d_vm_create()
 * \brief Create a Decision VM in its starting state, with malloc'd elements.
 *
 * \return A Decision VM in its starting state.
 */
DECISION_API DVM d_vm_create();

/**
 * \fn void d_vm_reset(DVM *vm)
 * \brief Reset a Decision VM to its starting state.
 *
 * \param vm A Decision VM to set to its starting state.
 */
DECISION_API void d_vm_reset(DVM *vm);

/**
 * \fn void d_vm_free(DVM *vm)
 * \brief Free the malloc'd elements of a Decision VM. Note that this makes the
 * VM unusable unless you call `d_vm_reset` on it.
 *
 * \param vm The Decision VM to free.
 */
DECISION_API void d_vm_free(DVM *vm);

/**
 * \fn void d_vm_runtime_error(DVM *vm, const char *error)
 * \brief Print a runtime error to `stdout`, and halt the VM.
 *
 * Unlike compiler errors, these errors aren't stored anywhere.
 *
 * \param vm The VM that came across the error.
 * \param error The error message to display.
 */
DECISION_API void d_vm_runtime_error(DVM *vm, const char *error);

/**
 * \def ERROR_RUNTIME(vm, ...)
 * \brief A macro function to be able to print formatted error messages.
 *
 * This is to `d_vm_runtime_error` what `ERROR_COMPILER` is to
 * `d_error_compiler_push`.
 */
#define ERROR_RUNTIME(vm, ...)            \
    {                                     \
        char errMsg[MAX_ERROR_SIZE];      \
        sprintf(errMsg, __VA_ARGS__);     \
        d_vm_runtime_error((vm), errMsg); \
    }

/**
 * \fn void d_vm_parse_ins_at_pc(DVM *vm)
 * \brief Given a Decision VM, at it's current position in the program, parse
 * the instruction at that position.
 *
 * \param vm The VM to use to parse the instruction.
 */
DECISION_API void d_vm_parse_ins_at_pc(DVM *vm);

/**
 * \fn void d_vm_add_pc(DVM *vm, dint rel)
 * \brief Add to the program counter to go +rel bytes.
 *
 * **NOTE:** The VM will ALWAYS increment the PC after any instruction that
 * isn't a jump, call or return.
 *
 * \param vm The VM whose PC to add to.
 * \param rel How many bytes to go forward. *Can* be negative.
 */
DECISION_API void d_vm_add_pc(DVM *vm, dint rel);

/**
 * \fn void d_vm_inc_pc(DVM *vm)
 * \brief Increment the program counter in a Decision VM, to go to the next
 * instruction.
 *
 * **NOTE:** The VM will ALWAYS increment the PC after any instruction that
 * isn't a jump, call or return.
 *
 * \param vm The VM whose PC to add to.
 */
DECISION_API void d_vm_inc_pc(DVM *vm);

/**
 * \fn bool d_vm_run(DVM *vm, void *start)
 * \brief Get a virtual machine to start running instructions in a loop, until
 * it is halted.
 *
 * \return If it ran without any runtime errors.
 *
 * \param vm The VM to run the bytecode in.
 * \param start A pointer to the start of the bytecode to execute.
 */
DECISION_API bool d_vm_run(DVM *vm, void *start);

/**
 * \fn void d_vm_dump(DVM *vm)
 * \brief Dump the contents of a Decision VM to stdout for debugging.
 *
 * \param vm The VM to dump the contents of.
 */
DECISION_API void d_vm_dump(DVM *vm);

#endif // DVM_H
