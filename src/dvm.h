/*
    Decision
    Copyright (C) 2019  Benjamin Beddows

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * \file dvm.h
 * \brief This header contains functionality for the Decision VM - the object
 * that will run the generated bytecode.
 */

#ifndef DVM_H
#define DVM_H

#include "dcfg.h"
#include "derror.h"
#include <stdbool.h>

#include <stdint.h>

/*
=== HEADER DEFINITIONS ====================================
*/

/**
 * \enum _dIns
 * \brief The Decision VM Instruction Set.
 *
 * \typedef enum _dIns DIns
 */
typedef enum _dIns {
    /*
        OP_RET   = 0,  ///< $( pc )  = pop(callStack) ELSE vm.halted = true
        OP_ADD   = 1,  ///< $( r1 )  = $( r1 ) + $( r2 )
        OP_ADDF  = 2,  ///< $( f1 )  = $( f1 ) + $( f2 )
        OP_ADDI  = 3,  ///< $( r )  += W_IMMEDIATE(4/2)
        OP_AND   = 4,  ///< $( r1 )  = $( r1 ) & $( r2 )
        OP_ANDI  = 5,  ///< $( r )  &= IMMEDIATE(4/2)
        OP_CALL  = 6,  ///< push(callStack, $( pc )); $( pc ) = $( r )
        OP_CALLC = 7,  ///< (*$( r ))(this)
        OP_CALLR = 8,  ///< push(callStack, $( pc )); $( pc ) +=
       W_IMMEDIATE(4/2) OP_CEQ   = 9,  ///< $( r1 )  = ($( r2 ) == $( r3 )) ? 1
       : 0 OP_CEQF  = 10, ///< $( r1 )  = ($( f2 ) == $( f3 )) ? 1 : 0 OP_CEQS
       = 11, ///< $( r1 )  = (strcmp($( r2 ), $( r3 )) == 0) ? 1 : 0 OP_CLEQ  =
       12, ///< $( r1 )  = ($( r2 ) <= $( r3 )) ? 1 : 0 OP_CLEQF = 13, ///< $(
       r1 )  = ($( f2 ) <= $( f3 )) ? 1 : 0 OP_CLEQS = 14, ///< $( r1 )  =
       (strcmp($( r2 ), $( r3 )) <= 0) ? 1 : 0 OP_CLT   = 15, ///< $( r1 )  =
       ($( r2 ) < $( r3 )) ? 1 : 0 OP_CLTF  = 16, ///< $( r1 )  = ($( f2 ) < $(
       f3 )) ? 1 : 0 OP_CLTS  = 17, ///< $( r1 )  = (strcmp($( r2 ), $( r3 )) <
       0) ? 1 : 0 OP_CMEQ  = 18, ///< $( r1 )  = ($( r2 ) >= $( r3 )) ? 1 : 0
        OP_CMEQF = 19, ///< $( r1 )  = ($( f2 ) >= $( f3 )) ? 1 : 0
        OP_CMEQS = 20, ///< $( r1 )  = (strcmp($( r2 ), $( r3 )) >= 0) ? 1 : 0
        OP_CMT   = 21, ///< $( r1 )  = ($( r2 ) > $( r3 )) ? 1 : 0
        OP_CMTF  = 22, ///< $( r1 )  = ($( f2 ) > $( f3 )) ? 1 : 0
        OP_CMTS  = 23, ///< $( r1 )  = (strcmp($( r2 ), $( r3 )) > 0) ? 1 : 0
        OP_CVTF  = 24, ///< $( f1 )  = (dfloat)$( r0 )
        OP_CVTI  = 25, ///< $( r1 )  = (dint)$(f0)
        OP_DIV   = 26, ///< $( r1 )  = $( r1 ) / $( r2 )
        OP_DIVF  = 27, ///< $( f1 )  = $( f1 ) / $( f2 )
        OP_DIVI  = 28, ///< $( r )   = $( r ) / W_IMMEDIATE(4/2)
        OP_J     = 29, ///< $( pc )  = $( r )
        OP_JCON  = 30, ///< $( pc )  = ($( r2 )) ? $( r1 ) : $( pc )
        OP_JR    = 31, ///< $( pc ) += W_IMMEDIATE(4/2)
        OP_JRCON =
            32, ///< $( pc )  = ($( r1 )) ? $( pc ) + W_IMMEDIATE(4/2) : $( pc )
        OP_LOAD     = 33, ///< $( r1 )  = $( r2 )
        OP_LOADADR  = 34, ///< $( r1 )  = *((dint*)$( r2 ))
        OP_LOADADRB = 35, ///< $( r1 )  = *((uint8_t*)$( r2 ))
        OP_LOADARG  = 36, ///< arg[r1] = $( r2 )
        OP_LOADARGI = 37, ///< arg[r1] = IMMEDIATE(4/2)
        OP_LOADF    = 38, ///< $( f1 )  = $( f2 )
        OP_LOADI    = 39, ///< $( r )   = IMMEDIATE(4/2)
        OP_LOADUI   = 40, ///< $( r )   = IMMEDIATE(4/2) << 32 / 16
        OP_MOD      = 41, ///< $( r1 ) %= $( r2 )
        OP_MODI     = 42, ///< $( r1 ) %= W_IMMEDIATE(4/2)
        OP_MUL      = 43, ///< $( r1 )  = $( r1 ) * $( r2 )
        OP_MULF     = 44, ///< $( f1 )  = $( f1 ) * $( f2 )
        OP_MULI     = 45, ///< $( r )   = $(r) * W_IMMEDIATE(4/2)
        OP_MVTF     = 46, ///< $( f1 )  = $( r0 )
        OP_MVTI     = 47, ///< $( r1 )  = $( f0 )
        OP_NOT      = 48, ///< $( r )   = !$( r )
        OP_OR       = 49, ///< $( r1 )  = $( r1 ) | $( r2 )
        OP_ORI      = 50, ///< $( r )  |= IMMEDIATE(4/2)
        OP_POP      = 51, ///< $( r )   = pop(generalStack)
        OP_PUSH     = 52, ///< push(generalStack, $( r ))
        OP_STOADR   = 53, ///< *((dint*)$( r2 )) = $( r1 )
        OP_STOADRB  = 54, ///< *((uint8_t*)$( r2 )) = $( r1 )
        OP_SUB      = 55, ///< $( r1 )  = $( r1 ) - $( r2 )
        OP_SUBF     = 56, ///< $( f1 )  = $( f1 ) - $( f2 )
        OP_SUBI     = 57, ///< $( r )  -= W_IMMEDIATE(4/2)
        OP_SYSCALL  = 58, ///< syscall(IMMEDIATE(1)), see `DSyscall`.
        OP_XOR      = 59, ///< $( r1 )  = $( r1 ) ^ $( r2 )
        OP_XORI     = 60, ///< $( r )  ^= IMMEDIATE(4/2)
    */
} DIns;

/**
 * \def NUM_OPCODES
 * \brief Macro constant representing the number of opcodes.
 */
// #define NUM_OPCODES (OP_XORI + 1)

/**
 * \enum _dSyscall
 * \brief The Decision VM Syscall specification.
 *
 * \typedef enum _dSyscall DSyscall
 */
/*
typedef enum _dSyscall {
    SYS_LOADSTR = 0, ///< Load a string value into a MALLOC'D string.
                     ///< * `arg0`: A register which contains a pointer to a
                     ///< MALLOC'D string, the string that is being set.
                     ///< If the new string is a different length, chances are
                     ///< the pointer to the malloc'd string will change, and
                     ///< so will this register.
                     ///< * `arg1`: A register which contains a pointer to the
                     ///< string to copy.

    SYS_PRINT = 1, ///< Print a value to `stdout`.
                   ///< * `arg0`: `0`: `Integer`, `1`: `Float`, `2`: `String`,
                   ///< `3`: `Boolean`.
                   ///< * `arg1`: The register to print.
                   ///< * `arg2`: If set to `1`, it will print a newline at the
                   ///< end, otherwise it will not.
} DSyscall;
*/

/**
 * \def VM_STACK_SIZE_MIN
 * \brief The minimum, and starting, size of the VM's stack.
 */
#define VM_STACK_SIZE_MIN 64

/**
 * \def VM_STACK_SIZE_SCALE_INC
 * \brief How much should the stack size increase once it reaches capacity?
 */
#define VM_STACK_SIZE_SCALE_INC 1.5

/**
 * \def VM_STACK_SIZE_SCALE_DEC
 * \brief How much should the stack size decrease to save memory?
 */
#define VM_STACK_SIZE_SCALE_DEC 0.5

/**
 * \enum _DVM
 * \brief The Decision VM structure.
 *
 * \typedef struct _DVM DVM
 */
typedef struct _DVM {
    char *pc;              ///< The program counter.
    unsigned char _inc_pc; ///< How many bytes to increment the program counter.
                           ///< This is determined automatically.

    dint *basePtr;  ///< A pointer to the base of the stack.
    dint *stackPtr; ///< A pointer to the top of the stack.
    dint *framePtr; ///< A pointer to the start of the stack frame.

    duint stackSize; ///< The current size of the stack.

    bool halted;       ///< The halted flag.
    bool runtimeError; ///< The runtime error flag.
} DVM;

/**
 * \def IMMEDIATE_SIZE
 * \brief The size of immediates in bytes.
 *
 * \def immediate_t
 * \brief A type to store immediates in.
 *
 * \def uimmediate_t
 * \brief A type to store unsigned immediates in.
 *
 * \def IMMEDIATE_MASK
 * \brief A mask to get the lower half of an immediate.
 *
 * \def IMMEDIATE_UPPER_MASK
 * \brief A mask to get the upper half of an immediate.
 */
/*
#ifdef DECISION_32
#define IMMEDIATE_SIZE       2
#define immediate_t          int16_t
#define uimmediate_t         uint16_t
#define IMMEDIATE_MASK       0xffff
#define IMMEDIATE_UPPER_MASK 0xffff0000
#else
#define IMMEDIATE_SIZE       4
#define immediate_t          int32_t
#define uimmediate_t         uint32_t
#define IMMEDIATE_MASK       0xffffffff
#define IMMEDIATE_UPPER_MASK 0xffffffff00000000
#endif // DECISION_32
*/

/**
 * \def GET_IMMEDIATE_PTR(ptr)
 * \brief Get a lower immediate value from a pointer.
 */
//#define GET_IMMEDIATE_PTR(ptr) (dint) * ((uimmediate_t *)(ptr))

/**
 * \def GET_UPPER_IMMEDIATE_PTR(ptr)
 * \brief Get an upper immediate value from a pointer.
 */
//#define GET_UPPER_IMMEDIATE_PTR(ptr) \
    (GET_IMMEDIATE_PTR(ptr) << IMMEDIATE_SIZE * 8)

/**
 * \def GET_BYTEN(ptr, n)
 * \brief Macro function to get the `n`th byte after a pointer `ptr`.
 */
//#define GET_BYTEN(ptr, n) *((unsigned char *)(ptr) + (n))

/*
=== STACK FUNCTIONS =======================================
*/

/**
 * \fn dint d_vm_get(DVM *vm, dint index)
 * \brief Get an integer from a value in the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \return The integer value of the stack at the given index.
 *
 * \param vm The VM whose stack to retrieve from.
 * \param index The index of the stack.
 */
DECISION_API dint d_vm_get(DVM *vm, dint index);

/**
 * \fn dfloat d_vm_get_float(DVM *vm, dint index)
 * \brief Get a float from a value in the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \return The float value of the stack at the given index.
 *
 * \param vm The VM whose stack to retrieve from.
 * \param index The index of the stack.
 */
DECISION_API dfloat d_vm_get_float(DVM *vm, dint index);

/**
 * \fn void *d_vm_get_float(DVM *vm, dint index)
 * \brief Get a pointer from a value in the stack at a particular index.
 *
 * * If `index` is positive, it will index relative to the start of the stack
 * frame.
 * * If `index` is non-positive, it will index relative to the top of the stack.
 *
 * \return The pointer value of the stack at the given index.
 *
 * \param vm The VM whose stack to retrieve from.
 * \param index The index of the stack.
 */
DECISION_API void *d_vm_get_ptr(DVM *vm, dint index);

/**
 * \fn dint d_vm_pop(DVM *vm)
 * \brief Pop an integer from the top of the stack.
 * 
 * \return The integer at the top of the stack.
 * 
 * \param vm The VM whose stack to pop from.
 */
DECISION_API dint d_vm_pop(DVM *vm);

/**
 * \fn void d_vm_popn(DVM *vm, size_t n)
 * \brief Pop `n` elements from the stack.
 * 
 * \param vm The VM whose stack to pop from.
 * \param n The number of elements to pop.
 */
DECISION_API void d_vm_popn(DVM *vm, size_t n);

/**
 * \fn dfloat d_vm_pop_float(DVM *vm)
 * \brief Pop a float from the top of the stack.
 * 
 * \return The float at the top of the stack.
 * 
 * \param vm The VM whose stack to pop from.
 */
DECISION_API dfloat d_vm_pop_float(DVM *vm);

/**
 * \fn void *d_vm_pop_ptr(DVM *vm)
 * \brief Pop a pointer from the top of the stack.
 * 
 * \return The pointer at the top of the stack.
 * 
 * \param vm The VM whose stack to pop from.
 */
DECISION_API void *d_vm_pop_ptr(DVM *vm);

/**
 * \fn void d_vm_push(DVM *vm, dint value)
 * \brief Push an integer value onto the stack.
 * 
 * \param vm The VM whose stack to push onto.
 * \param value The value to push onto the stack.
 */
DECISION_API void d_vm_push(DVM *vm, dint value);

/**
 * \fn void d_vm_push_float(DVM *vm, dfloat value)
 * \brief Push a float value onto the stack.
 * 
 * \param vm The VM whose stack to push onto.
 * \param value The value to push onto the stack.
 */
DECISION_API void d_vm_push_float(DVM *vm, dfloat value);

/**
 * \fn void d_vm_push_ptr(DVM *vm, void *ptr)
 * \brief Push a pointer onto the stack.
 * 
 * \param vm The VM whose stack to push onto.
 * \param ptr The pointer to push onto the stack.
 */
DECISION_API void d_vm_push_ptr(DVM *vm, void *ptr);

/**
 * \fn size_t d_vm_top(DVM *vm)
 * \brief Get the number of elements in the stack.
 * 
 * \return The number of elements in the stack.
 * 
 * \param vm The VM whose stack to query.
 */
DECISION_API size_t d_vm_top(DVM *vm);

/*
=== VM FUNCTIONS ==========================================
*/

/**
 * \fn const unsigned char d_vm_ins_size(DIns opcode)
 * \brief Given an opcode, get the total size of the instruction involving that
 * opcode in bytes.
 *
 * \return The size of the instruction in bytes. 0 if the opcode doesn't exist.
 *
 * \param opcode The opcode to query.
 */
// DECISION_API const unsigned char d_vm_ins_size(DIns opcode);

/**
 * \fn DVM d_vm_create()
 * \brief Create a Decision VM in its starting state, with malloc'd elements.
 *
 * \return A Decision VM in its starting state.
 */
DECISION_API DVM d_vm_create();

/**
 * \fn void d_vm_reset(DVM *vm)
 * \brief Reset a Decision VM to its starting state.
 *
 * \param vm A Decision VM to set to its starting state.
 */
DECISION_API void d_vm_reset(DVM *vm);

/**
 * \fn void d_vm_free(DVM *vm)
 * \brief Free the malloc'd elements of a Decision VM. Note that this makes the
 * VM unusable unless you call `d_vm_reset` on it.
 *
 * \param vm The Decision VM to free.
 */
DECISION_API void d_vm_free(DVM *vm);

/**
 * \fn void d_vm_runtime_error(DVM *vm, const char *error)
 * \brief Print a runtime error to `stdout`, and halt the VM.
 *
 * Unlike compiler errors, these errors aren't stored anywhere.
 *
 * \param vm The VM that came across the error.
 * \param error The error message to display.
 */
DECISION_API void d_vm_runtime_error(DVM *vm, const char *error);

/**
 * \def ERROR_RUNTIME(vm, ...)
 * \brief A macro function to be able to print formatted error messages.
 *
 * This is to `d_vm_runtime_error` what `ERROR_COMPILER` is to
 * `d_error_compiler_push`.
 */
#ifdef DECISION_SAFE_FUNCTIONS
#define ERROR_RUNTIME(vm, ...)                          \
    {                                                   \
        char errMsg[MAX_ERROR_SIZE];                    \
        sprintf_s(errMsg, MAX_ERROR_SIZE, __VA_ARGS__); \
        d_vm_runtime_error((vm), errMsg);               \
    }
#else
#define ERROR_RUNTIME(vm, ...)            \
    {                                     \
        char errMsg[MAX_ERROR_SIZE];      \
        sprintf(errMsg, __VA_ARGS__);     \
        d_vm_runtime_error((vm), errMsg); \
    }
#endif // DECISION_SAFE_FUNCTIONS

/**
 * \fn void d_vm_parse_ins_at_pc(DVM *vm)
 * \brief Given a Decision VM, at it's current position in the program, parse
 * the instruction at that position.
 *
 * \param vm The VM to use to parse the instruction.
 */
// DECISION_API void d_vm_parse_ins_at_pc(DVM *vm);

/**
 * \fn void d_vm_add_pc(DVM *vm, dint rel)
 * \brief Add to the program counter to go +rel bytes.
 *
 * **NOTE:** The VM will ALWAYS increment the PC after any instruction that
 * isn't a jump, call or return.
 *
 * \param vm The VM whose PC to add to.
 * \param rel How many bytes to go forward. *Can* be negative.
 */
DECISION_API void d_vm_add_pc(DVM *vm, dint rel);

/**
 * \fn void d_vm_inc_pc(DVM *vm)
 * \brief Increment the program counter in a Decision VM, to go to the next
 * instruction.
 *
 * **NOTE:** The VM will ALWAYS increment the PC after any instruction that
 * isn't a jump, call or return.
 *
 * \param vm The VM whose PC to add to.
 */
DECISION_API void d_vm_inc_pc(DVM *vm);

/**
 * \fn bool d_vm_run(DVM *vm, void *start)
 * \brief Get a virtual machine to start running instructions in a loop, until
 * it is halted.
 *
 * \return If it ran without any runtime errors.
 *
 * \param vm The VM to run the bytecode in.
 * \param start A pointer to the start of the bytecode to execute.
 */
DECISION_API bool d_vm_run(DVM *vm, void *start);

#endif // DVM_H
