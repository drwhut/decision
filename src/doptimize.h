/*
    Decision
    Copyright (C) 2019  Benjamin Beddows

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * \file doptimize.h
 * \brief This header deals with optimising generated bytecode from `dcodegen.h`
 * by checking for specific senarios and helps to reduce the number of
 * instructions.
 */

#ifndef DOPTIMIZE_H
#define DOPTIMIZE_H

#include <stdbool.h>
#include "dcfg.h"

#include <stddef.h>

/*
=== HEADER DEFINITIONS ====================================
*/

/* Forward declaration of the Sheet struct from dsheet.h */
struct _sheet;

/*
=== FUNCTIONS =============================================
*/

/**
 * \fn void d_optimize_remove_ins_to_link(Sheet *sheet, size_t index)
 * \brief Remove one instruction-to-link record from a sheet.
 *
 * \param sheet The sheet to remove the record from.
 * \param index The index of the record to remove.
 */
DECISION_API void d_optimize_remove_ins_to_link(struct _sheet *sheet,
                                                size_t index);

/**
 * \fn void d_optimize_remove_bytecode(Sheet *sheet, size_t start, size_t len)
 * \brief Remove a section of bytecode, and make any adjustments to the data
 * that is nessesary.
 *
 * \param sheet The sheet containing the bytecode to remove from.
 * \param start The starting index of the bytecode to remove.
 * \param len How many bytes to remove, starting from `start`.
 */
DECISION_API void d_optimize_remove_bytecode(struct _sheet *sheet, size_t start,
                                             size_t len);

/**
 * \fn void d_optimize_all(Sheet *sheet)
 * \brief Try and optimise all possible senarios.
 *
 * \param sheet The sheet containing the bytecode to optimise.
 */
DECISION_API void d_optimize_all(struct _sheet *sheet);

/**
 * \fn bool d_optimize_not_consecutive(Sheet *sheet)
 * \brief Try and find consecutive NOT instructions that NOT the same register.
 *
 * \return If we were able to optimise.
 *
 * \param sheet The sheet containing the bytecode to optimize.
 */
DECISION_API bool d_optimize_not_consecutive(struct _sheet *sheet);

/**
 * \fn bool d_optimize_call_func_relative(Sheet *sheet)
 * \brief Try and find instructions that link to functions that are defined in
 * the same sheet, and if possible, just replace with a relative call rather
 * than an absolute one.
 *
 * \return If we were able to optimise.
 *
 * \param sheet The sheet containing the bytecode to optimize.
 */
DECISION_API bool d_optimize_call_func_relative(struct _sheet *sheet);

#endif // DOPTIMIZE_H